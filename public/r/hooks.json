{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "hooks",
  "type": "registry:hook",
  "dependencies": [
    "openapi-types",
    "react"
  ],
  "registryDependencies": [
    "https://pivotkit.vercel.app/r/utils",
    "https://pivotkit.vercel.app/r/hooks",
    "https://pivotkit.vercel.app/r/resolve-ref"
  ],
  "files": [
    {
      "path": "registry/lib/hooks/use-openapi.ts",
      "content": "\nimport { resolveRef } from \"@/registry/lib/utils/resolve-ref\";\nimport type { OpenAPIV3 } from 'openapi-types';\nimport { useMemo } from \"react\";\n\n/**\n * 自定义钩子，简化OpenAPI结构的处理\n * @param spec OpenAPI规范对象或null\n * @returns 一组处理OpenAPI结构的工具函数\n */\nexport function useOpenApi(spec: OpenAPIV3.Document | null) {\n  // 当spec为null时，返回空的组件\n  const components = spec?.components;\n\n  // 优化引用解析，避免重复计算\n  const resolve = useMemo(() => {\n    return function resolve<T>(\n      obj: T | OpenAPIV3.ReferenceObject | undefined,\n      category?: string,\n    ): T | null {\n      if (!spec || !components) return null;\n      return resolveRef<T>(obj, components, category);\n    };\n  }, [components, spec]);\n\n  /**\n   * 获取模式的类型信息\n   * @param schema 模式对象\n   * @returns 类型信息字符串\n   */\n  const getSchemaType = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ): string => {\n    if (!schema) return \"未知\";\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return \"未知\";\n\n    let type = resolvedSchema.type || \"\";\n\n    // 处理数组类型\n    if (type === \"array\" && 'items' in resolvedSchema && resolvedSchema.items) {\n      const itemType = getSchemaType(resolvedSchema.items);\n      return `${type}<${itemType}>`;\n    }\n\n    // 处理对象或复合类型\n    if (type === \"object\" || !type) {\n      if (resolvedSchema.properties) {\n        return \"object\";\n      }\n      if (resolvedSchema.allOf) {\n        return \"allOf\";\n      }\n      if (resolvedSchema.oneOf) {\n        return \"oneOf\";\n      }\n      if (resolvedSchema.anyOf) {\n        return \"anyOf\";\n      }\n    }\n\n    // 处理格式化的类型\n    if (resolvedSchema.format) {\n      return `${type}(${resolvedSchema.format})`;\n    }\n\n    return type || \"未知\";\n  };\n\n  /**\n   * 从请求体中获取模式对象\n   * @param requestBody 请求体对象\n   * @returns 解析后的模式对象\n   */\n  const getRequestBodySchema = (\n    requestBody: OpenAPIV3.RequestBodyObject | OpenAPIV3.ReferenceObject | undefined,\n  ): OpenAPIV3.SchemaObject | null => {\n    if (!requestBody) return null;\n\n    const resolvedBody = resolve<OpenAPIV3.RequestBodyObject>(\n      requestBody,\n      \"requestBodies\",\n    );\n    if (!resolvedBody || !resolvedBody.content) return null;\n\n    // 尝试获取常见内容类型\n    const contentTypes = [\"application/json\", \"application/xml\", \"*/*\"];\n    for (const contentType of contentTypes) {\n      if (resolvedBody.content[contentType]?.schema) {\n        return (\n          resolve<OpenAPIV3.SchemaObject>(\n            resolvedBody.content[contentType].schema,\n            \"schemas\",\n          ) || null\n        );\n      }\n    }\n\n    // 如果找不到常见类型，使用第一个可用类型\n    const firstContentType = Object.keys(resolvedBody.content)[0];\n    if (firstContentType && resolvedBody.content[firstContentType]?.schema) {\n      return (\n        resolve<OpenAPIV3.SchemaObject>(\n          resolvedBody.content[firstContentType].schema,\n          \"schemas\",\n        ) || null\n      );\n    }\n\n    return null;\n  };\n\n  /**\n   * 获取模式的属性信息\n   * @param schema 模式对象\n   * @returns 属性对象集合\n   */\n  const getSchemaProperties = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!schema) return {};\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return {};\n\n    // 处理基本对象\n    if (resolvedSchema.properties) {\n      return resolvedSchema.properties;\n    }\n\n    // 处理数组\n    if (resolvedSchema.type === \"array\" && 'items' in resolvedSchema && resolvedSchema.items) {\n      const itemsSchema = resolve<OpenAPIV3.SchemaObject>(\n        resolvedSchema.items,\n        \"schemas\",\n      );\n      if (itemsSchema?.properties) {\n        return itemsSchema.properties;\n      }\n    }\n\n    // 处理组合模式\n    if (resolvedSchema.allOf) {\n      // 合并所有allOf模式的属性\n      const mergedProperties = {};\n      for (const subSchema of resolvedSchema.allOf) {\n        const subProperties = getSchemaProperties(subSchema);\n        Object.assign(mergedProperties, subProperties);\n      }\n      return mergedProperties;\n    }\n\n    return {};\n  };\n\n  /**\n   * 处理参数集合，按位置分组\n   * @param parameters 参数对象数组\n   * @returns 按位置分组的参数\n   */\n  const processParameters = (\n    parameters: (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[] | undefined,\n  ) => {\n    if (!parameters || parameters.length === 0) {\n      return {};\n    }\n\n    const result: { [key: string]: (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[] } = {\n      path: [],\n      query: [],\n      header: [],\n      cookie: [],\n    };\n\n    for (const param of parameters) {\n      const resolvedParam = resolve<OpenAPIV3.ParameterObject>(param, \"parameters\");\n      if (resolvedParam && resolvedParam.in) {\n        const paramIn = resolvedParam.in as keyof typeof result;\n        if (paramIn in result && result[paramIn]) {\n          result[paramIn].push(resolvedParam);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * 处理响应对象\n   * @param response 响应对象\n   * @returns 处理后的响应对象\n   */\n  const processResponse = (\n    response: OpenAPIV3.ResponseObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!response) return null;\n\n    const resolvedResponse = resolve<OpenAPIV3.ResponseObject>(response, \"responses\");\n    if (!resolvedResponse) return null;\n\n    const result = {\n      description: resolvedResponse.description || \"\",\n      headers: resolvedResponse.headers || {},\n      content: resolvedResponse.content || {},\n    };\n\n    return result;\n  };\n\n  /**\n   * 获取模式的约束条件\n   * @param schema 模式对象\n   * @returns 约束条件对象\n   */\n  const getSchemaConstraints = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!schema) return {};\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return {};\n\n    const constraints: { [key: string]: any } = {};\n\n    // 数值约束\n    if (typeof resolvedSchema.minimum === \"number\") {\n      constraints.minimum = resolvedSchema.minimum;\n    }\n    if (typeof resolvedSchema.maximum === \"number\") {\n      constraints.maximum = resolvedSchema.maximum;\n    }\n    if (typeof resolvedSchema.exclusiveMinimum === \"number\") {\n      constraints.exclusiveMinimum = resolvedSchema.exclusiveMinimum;\n    }\n    if (typeof resolvedSchema.exclusiveMaximum === \"number\") {\n      constraints.exclusiveMaximum = resolvedSchema.exclusiveMaximum;\n    }\n    if (typeof resolvedSchema.multipleOf === \"number\") {\n      constraints.multipleOf = resolvedSchema.multipleOf;\n    }\n\n    // 字符串约束\n    if (typeof resolvedSchema.minLength === \"number\") {\n      constraints.minLength = resolvedSchema.minLength;\n    }\n    if (typeof resolvedSchema.maxLength === \"number\") {\n      constraints.maxLength = resolvedSchema.maxLength;\n    }\n    if (resolvedSchema.pattern) {\n      constraints.pattern = resolvedSchema.pattern;\n    }\n\n    // 数组约束\n    if (typeof resolvedSchema.minItems === \"number\") {\n      constraints.minItems = resolvedSchema.minItems;\n    }\n    if (typeof resolvedSchema.maxItems === \"number\") {\n      constraints.maxItems = resolvedSchema.maxItems;\n    }\n    if (resolvedSchema.uniqueItems) {\n      constraints.uniqueItems = resolvedSchema.uniqueItems;\n    }\n\n    // 对象约束\n    if (typeof resolvedSchema.minProperties === \"number\") {\n      constraints.minProperties = resolvedSchema.minProperties;\n    }\n    if (typeof resolvedSchema.maxProperties === \"number\") {\n      constraints.maxProperties = resolvedSchema.maxProperties;\n    }\n\n    return constraints;\n  };\n\n  /**\n   * 获取指定路径和方法的操作对象\n   * @param path 路径\n   * @param method HTTP方法\n   * @returns 操作对象\n   */\n  const getOperation = (\n    path: string,\n    method: string,\n  ): OpenAPIV3.OperationObject | null => {\n    if (!spec || !spec.paths || !spec.paths[path]) {\n      return null;\n    }\n\n    const pathItem = spec.paths[path] as OpenAPIV3.PathItemObject;\n    const operation = pathItem[method.toLowerCase() as keyof OpenAPIV3.PathItemObject];\n\n    if (operation && typeof operation === \"object\" && \"responses\" in operation) {\n      return operation as OpenAPIV3.OperationObject;\n    }\n\n    return null;\n  };\n\n  /**\n   * 获取服务器列表\n   * @returns 服务器对象数组\n   */\n  const getServers = (): OpenAPIV3.ServerObject[] => {\n    return spec?.servers || [];\n  };\n\n  /**\n   * 按标签分组获取操作\n   * @returns 按标签分组的操作对象\n   */\n  const getOperationsByTag = () => {\n    if (!spec || !spec.paths) {\n      return {};\n    }\n\n    const operations: { [tag: string]: Array<{ path: string; method: string; operation: OpenAPIV3.OperationObject }> } = {};\n\n    Object.entries(spec.paths).forEach(([path, pathItem]) => {\n      if (!pathItem || typeof pathItem !== \"object\") return;\n\n      const methods = [\"get\", \"post\", \"put\", \"delete\", \"patch\", \"head\", \"options\", \"trace\"];\n\n      methods.forEach((method) => {\n        const operation = pathItem[method as keyof OpenAPIV3.PathItemObject];\n        if (operation && typeof operation === \"object\" && \"responses\" in operation) {\n          const op = operation as OpenAPIV3.OperationObject;\n          const tags = op.tags || [\"default\"];\n\n          tags.forEach((tag) => {\n            if (!operations[tag]) {\n              operations[tag] = [];\n            }\n            operations[tag].push({\n              path,\n              method: method.toUpperCase(),\n              operation: op,\n            });\n          });\n        }\n      });\n    });\n\n    return operations;\n  };\n\n  /**\n   * 获取所有标签\n   * @returns 标签数组\n   */\n  const getTags = () => {\n    if (!spec) return [];\n    return spec.tags || [];\n  };\n\n  /**\n   * 获取API信息\n   * @returns API信息对象\n   */\n  const getInfo = () => {\n    return spec?.info || null;\n  };\n\n  /**\n   * 获取组件定义\n   * @returns 组件对象\n   */\n  const getComponents = () => {\n    return spec?.components || null;\n  };\n\n  return {\n    // 原始数据\n    spec,\n    components,\n\n    // 解析函数\n    resolve,\n\n    // 模式处理\n    getSchemaType,\n    getSchemaProperties,\n    getSchemaConstraints,\n    getRequestBodySchema,\n\n    // 参数和响应处理\n    processParameters,\n    processResponse,\n\n    // 操作处理\n    getOperation,\n    getOperationsByTag,\n    getTags,\n\n    // 服务器和基本信息\n    getServers,\n    getInfo,\n    getComponents,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/lib/hooks/use-operation.ts",
      "content": "import { useMemo } from 'react';\n\n/**\n * Hook for working with OpenAPI operations\n * @param operation - The operation object\n * @param path - The path string\n * @param method - The HTTP method\n * @returns Operation utilities\n */\nexport function useOperation(\n  operation: any,\n  path: string,\n  method: string\n) {\n  return useMemo(() => {\n    const getOperationId = () => {\n      return operation.operationId || `${method.toLowerCase()}-${path}`;\n    };\n\n    const getTags = () => {\n      return operation.tags || [];\n    };\n\n    const getParameters = () => {\n      return operation.parameters || [];\n    };\n\n    const getRequestBody = () => {\n      return operation.requestBody;\n    };\n\n    const getResponses = () => {\n      return operation.responses || {};\n    };\n\n    const getSecurity = () => {\n      return operation.security || [];\n    };\n\n    return {\n      getOperationId,\n      getTags,\n      getParameters,\n      getRequestBody,\n      getResponses,\n      getSecurity,\n    };\n  }, [operation, path, method]);\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/lib/hooks/use-schema.ts",
      "content": "import { useMemo } from 'react';\nimport { resolveRef } from '../utils/resolve-ref';\n\n/**\n * Hook for working with OpenAPI schemas\n * @param schema - The schema object or reference\n * @param components - The components object containing schemas\n * @returns Resolved schema and utility functions\n */\nexport function useSchema(\n  schema: any,\n  components: any\n) {\n  return useMemo(() => {\n    const resolvedSchema = schema.$ref ? resolveRef(schema, components) : schema;\n\n    const getType = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== 'object') return 'unknown';\n      return resolvedSchema.type || 'object';\n    };\n\n    const isRequired = (propertyName: string) => {\n      if (!resolvedSchema || typeof resolvedSchema !== 'object') return false;\n      return resolvedSchema.required?.includes(propertyName) || false;\n    };\n\n    const getProperties = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== 'object') return {};\n      return resolvedSchema.properties || {};\n    };\n\n    return {\n      resolvedSchema,\n      getType,\n      isRequired,\n      getProperties,\n    };\n  }, [schema, components]);\n}\n",
      "type": "registry:hook"
    }
  ]
}