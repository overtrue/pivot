{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "hooks",
  "type": "registry:hook",
  "description": "React hooks collection",
  "dependencies": [
    "js-yaml",
    "openapi-types",
    "react"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-openapi-combined.ts",
      "content": "\"use client\";\n\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useMemo } from \"react\";\nimport { useOpenApi } from \"./use-openapi\";\nimport { useOpenAPILoader } from \"./use-openapi-loader\";\n\n// 组合 Hook 的返回类型\nexport interface UseOpenAPICombinedResult {\n  // 来自 loader 的状态和方法\n  spec: OpenAPIV3.Document | null;\n  loading: boolean;\n  error: string | null;\n  loadFromUrl: (url: string) => Promise<void>;\n  loadFromString: (content: string) => Promise<void>;\n  loadFromObject: (spec: OpenAPIV3.Document) => void;\n  reload: () => Promise<void>;\n  reset: () => void;\n\n  // 来自 openapi 的处理方法\n  openapi: ReturnType<typeof useOpenApi>;\n}\n\n/**\n * 组合 Hook - 整合数据加载和数据处理\n *\n * 这个 Hook 展示了如何正确地组合使用：\n * - useOpenAPILoader: 专门处理数据获取和格式转换\n * - useOpenApi: 专门处理已解析数据的结构操作\n *\n * @example\n * ```tsx\n * // 基础使用\n * const api = useOpenAPICombined();\n *\n * // 加载数据\n * await api.loadFromUrl('https://api.example.com/openapi.json');\n *\n * // 使用处理方法\n * const operations = api.openapi.getOperationsByTag();\n * const servers = api.openapi.getServers();\n * ```\n */\nexport function useOpenAPICombined(\n  input?: OpenAPIV3.Document | string | null | undefined\n): UseOpenAPICombinedResult {\n  // 数据加载层\n  const loader = useOpenAPILoader(input);\n\n  // 数据处理层 - 只有当 spec 存在时才进行处理\n  const openapi = useOpenApi(loader.spec);\n\n  // 返回组合结果\n  return useMemo(() => ({\n    // 直接透传 loader 的所有属性和方法\n    ...loader,\n\n    // 添加 openapi 处理器\n    openapi,\n  }), [loader, openapi]);\n}\n\n/**\n * 便捷的 URL 加载 Hook\n *\n * @example\n * ```tsx\n * const { spec, loading, error, openapi } = useOpenAPIFromUrl(\n *   'https://petstore3.swagger.io/api/v3/openapi.json'\n * );\n *\n * if (loading) return <div>Loading...</div>;\n * if (error) return <div>Error: {error}</div>;\n *\n * const operations = openapi.getOperationsByTag();\n * ```\n */\nexport function useOpenAPIFromUrl(url: string) {\n  return useOpenAPICombined(url);\n}\n\n/**\n * 便捷的字符串解析 Hook\n *\n * @example\n * ```tsx\n * const yamlContent = `\n * openapi: 3.0.0\n * info:\n *   title: My API\n *   version: 1.0.0\n * paths: {}\n * `;\n *\n * const { spec, error, openapi } = useOpenAPIFromString(yamlContent);\n * ```\n */\nexport function useOpenAPIFromString(content: string) {\n  return useOpenAPICombined(content);\n}\n\n/**\n * 便捷的对象 Hook\n *\n * @example\n * ```tsx\n * const spec: OpenAPIV3.Document = { ... };\n * const { openapi } = useOpenAPIFromObject(spec);\n * ```\n */\nexport function useOpenAPIFromObject(spec: OpenAPIV3.Document) {\n  return useOpenAPICombined(spec);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi-combined.ts"
    },
    {
      "path": "registry/default/hooks/use-openapi-loader.ts",
      "content": "\"use client\";\n\nimport * as yaml from \"js-yaml\";\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\n// 数据源类型\nexport type OpenAPISource =\n  | { type: \"object\"; data: OpenAPIV3.Document }\n  | { type: \"string\"; data: string }\n  | { type: \"url\"; data: string };\n\n// Hook 状态\nexport interface UseOpenAPILoaderState {\n  spec: OpenAPIV3.Document | null;\n  loading: boolean;\n  error: string | null;\n}\n\n// Hook 返回值\nexport interface UseOpenAPILoaderResult extends UseOpenAPILoaderState {\n  loadFromUrl: (url: string) => Promise<void>;\n  loadFromString: (content: string) => Promise<void>;\n  loadFromObject: (spec: OpenAPIV3.Document) => void;\n  reload: () => Promise<void>;\n  reset: () => void;\n}\n\n/**\n * 智能判断输入类型并转换为 OpenAPISource\n */\nfunction createOpenAPISource(input: OpenAPIV3.Document | string | null | undefined): OpenAPISource | undefined {\n  if (!input) return undefined;\n\n  if (typeof input === \"string\") {\n    // 检测字符串是否为 URL\n    const isUrl = input.startsWith(\"http://\") || input.startsWith(\"https://\") || input.startsWith(\"/\");\n    return isUrl\n      ? { type: \"url\", data: input }\n      : { type: \"string\", data: input };\n  }\n\n  if (typeof input === \"object\" && input !== null) {\n    return { type: \"object\", data: input };\n  }\n\n  return undefined;\n}\n\n/**\n * OpenAPI 数据加载器 Hook\n * 专门处理数据获取、格式转换和缓存\n * 支持智能判断输入类型\n */\nexport function useOpenAPILoader(\n  input?: OpenAPIV3.Document | string | null | undefined\n): UseOpenAPILoaderResult {\n  const [state, setState] = useState<UseOpenAPILoaderState>({\n    spec: null,\n    loading: false,\n    error: null,\n  });\n\n  const [currentSource, setCurrentSource] = useState<OpenAPISource | null>(null);\n\n  // 智能判断输入并创建数据源\n  const dataSource = useMemo(() => createOpenAPISource(input), [input]);\n\n  // 解析字符串内容（JSON 或 YAML）\n  const parseContent = useCallback((content: string): OpenAPIV3.Document => {\n    // 先尝试 JSON\n    try {\n      return JSON.parse(content);\n    } catch (jsonError) {\n      // JSON 失败，尝试 YAML\n      try {\n        const yamlData = yaml.load(content);\n        if (typeof yamlData === \"object\" && yamlData !== null) {\n          return yamlData as OpenAPIV3.Document;\n        }\n        throw new Error(\"YAML 解析结果不是有效对象\");\n      } catch (yamlError) {\n        throw new Error(\n          `无法解析内容: JSON 错误: ${jsonError instanceof Error ? jsonError.message : \"未知错误\"}, YAML 错误: ${yamlError instanceof Error ? yamlError.message : \"未知错误\"}`\n        );\n      }\n    }\n  }, []);\n\n  // 从 URL 加载\n  const loadFromUrl = useCallback(async (url: string) => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    setCurrentSource({ type: \"url\", data: url });\n\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const content = await response.text();\n      const parsedSpec = parseContent(content);\n\n      setState({\n        spec: parsedSpec,\n        loading: false,\n        error: null,\n      });\n    } catch (error) {\n      setState({\n        spec: null,\n        loading: false,\n        error: error instanceof Error ? error.message : \"加载失败\",\n      });\n    }\n  }, [parseContent]);\n\n  // 从字符串加载\n  const loadFromString = useCallback(async (content: string) => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    setCurrentSource({ type: \"string\", data: content });\n\n    try {\n      const parsedSpec = parseContent(content);\n      setState({\n        spec: parsedSpec,\n        loading: false,\n        error: null,\n      });\n    } catch (error) {\n      setState({\n        spec: null,\n        loading: false,\n        error: error instanceof Error ? error.message : \"解析失败\",\n      });\n    }\n  }, [parseContent]);\n\n  // 从对象加载\n  const loadFromObject = useCallback((spec: OpenAPIV3.Document) => {\n    setCurrentSource({ type: \"object\", data: spec });\n    setState({\n      spec,\n      loading: false,\n      error: null,\n    });\n  }, []);\n\n  // 重新加载当前源\n  const reload = useCallback(async () => {\n    if (!currentSource) return;\n\n    switch (currentSource.type) {\n      case \"url\":\n        await loadFromUrl(currentSource.data);\n        break;\n      case \"string\":\n        await loadFromString(currentSource.data);\n        break;\n      case \"object\":\n        loadFromObject(currentSource.data);\n        break;\n    }\n  }, [currentSource, loadFromUrl, loadFromString, loadFromObject]);\n\n  // 重置状态\n  const reset = useCallback(() => {\n    setState({\n      spec: null,\n      loading: false,\n      error: null,\n    });\n    setCurrentSource(null);\n  }, []);\n\n  // 处理数据源变化\n  useEffect(() => {\n    if (dataSource) {\n      switch (dataSource.type) {\n        case \"url\":\n          loadFromUrl(dataSource.data);\n          break;\n        case \"string\":\n          loadFromString(dataSource.data);\n          break;\n        case \"object\":\n          loadFromObject(dataSource.data);\n          break;\n      }\n    } else {\n      // 如果没有数据源，重置状态\n      reset();\n    }\n  }, [dataSource, loadFromUrl, loadFromString, loadFromObject, reset]);\n\n  return {\n    ...state,\n    loadFromUrl,\n    loadFromString,\n    loadFromObject,\n    reload,\n    reset,\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi-loader.ts"
    },
    {
      "path": "registry/default/hooks/use-openapi.ts",
      "content": "\"use client\";\n\nimport { resolveRef } from \"@/registry/default/lib/resolve-ref\";\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useMemo } from \"react\";\n\n/**\n * 简化的 OpenAPI 处理钩子\n * @param spec OpenAPI规范对象或null\n * @param components 可选的组件对象\n * @returns 基本的 OpenAPI 处理工具\n */\nexport function useOpenApi(spec: OpenAPIV3.Document | null, components?: OpenAPIV3.ComponentsObject) {\n  // 优先使用传入的components，如果没有则使用spec中的components\n  const effectiveComponents = useMemo(() => components || spec?.components, [components, spec?.components]);\n\n  // 引用解析函数\n  const resolve = useMemo(() => {\n    return function resolve<T>(\n      obj: T | OpenAPIV3.ReferenceObject | undefined,\n      category?: string,\n    ): T | null {\n      if (!effectiveComponents) return null;\n      return resolveRef<T>(obj, effectiveComponents, category);\n    };\n  }, [effectiveComponents]);\n\n  return useMemo(() => ({\n    // 原始数据\n    spec,\n    components: effectiveComponents,\n\n    // 状态检查\n    hasComponents: !!effectiveComponents,\n\n    // 解析函数\n    resolve,\n  }), [spec, effectiveComponents, resolve]);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi.ts"
    },
    {
      "path": "registry/default/hooks/use-operation.ts",
      "content": "\"use client\";\n\nimport { useMemo } from \"react\";\n\n/**\n * Hook for working with OpenAPI operations\n * @param operation - The operation object\n * @param path - The path string\n * @param method - The HTTP method\n * @returns Operation utilities\n */\nexport function useOperation(operation: any, path: string, method: string) {\n  return useMemo(() => {\n    const getOperationId = () => {\n      return operation.operationId || `${method.toLowerCase()}-${path}`;\n    };\n\n    const getTags = () => {\n      return operation.tags || [];\n    };\n\n    const getParameters = () => {\n      return operation.parameters || [];\n    };\n\n    const getRequestBody = () => {\n      return operation.requestBody;\n    };\n\n    const getResponses = () => {\n      return operation.responses || {};\n    };\n\n    const getSecurity = () => {\n      return operation.security || [];\n    };\n\n    return {\n      getOperationId,\n      getTags,\n      getParameters,\n      getRequestBody,\n      getResponses,\n      getSecurity,\n    };\n  }, [operation, path, method]);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-operation.ts"
    },
    {
      "path": "registry/default/hooks/use-schema.ts",
      "content": "\"use client\";\n\nimport { resolveRef } from \"@/registry/default/lib/resolve-ref\";\nimport { useMemo } from \"react\";\n\n/**\n * Hook for working with OpenAPI schemas\n * @param schema - The schema object or reference\n * @param components - The components object containing schemas\n * @returns Resolved schema and utility functions\n */\nexport function useSchema(schema: any, components: any) {\n  return useMemo(() => {\n    const resolvedSchema = schema.$ref\n      ? resolveRef(schema, components)\n      : schema;\n\n    const getType = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\")\n        return \"unknown\";\n      return resolvedSchema.type || \"object\";\n    };\n\n    const isRequired = (propertyName: string) => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\") return false;\n      return resolvedSchema.required?.includes(propertyName) || false;\n    };\n\n    const getProperties = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\") return {};\n      return resolvedSchema.properties || {};\n    };\n\n    return {\n      resolvedSchema,\n      getType,\n      isRequired,\n      getProperties,\n    };\n  }, [schema, components]);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-schema.ts"
    }
  ]
}