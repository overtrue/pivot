{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "hooks",
  "type": "registry:hook",
  "description": "React hooks collection",
  "dependencies": [
    "js-yaml",
    "openapi-types",
    "react"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-openapi-combined.ts",
      "content": "\"use client\";\n\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useMemo } from \"react\";\nimport { useOpenApi } from \"./use-openapi\";\nimport { useOpenAPILoader } from \"./use-openapi-loader\";\n\n// 组合 Hook 的返回类型\nexport interface UseOpenAPICombinedResult {\n  // 来自 loader 的状态和方法\n  spec: OpenAPIV3.Document | null;\n  loading: boolean;\n  error: string | null;\n  loadFromUrl: (url: string) => Promise<void>;\n  loadFromString: (content: string) => Promise<void>;\n  loadFromObject: (spec: OpenAPIV3.Document) => void;\n  reload: () => Promise<void>;\n  reset: () => void;\n\n  // 来自 openapi 的处理方法\n  openapi: ReturnType<typeof useOpenApi>;\n}\n\n/**\n * 组合 Hook - 整合数据加载和数据处理\n *\n * 这个 Hook 展示了如何正确地组合使用：\n * - useOpenAPILoader: 专门处理数据获取和格式转换\n * - useOpenApi: 专门处理已解析数据的结构操作\n *\n * @example\n * ```tsx\n * // 基础使用\n * const api = useOpenAPICombined();\n *\n * // 加载数据\n * await api.loadFromUrl('https://api.example.com/openapi.json');\n *\n * // 使用处理方法\n * const operations = api.openapi.getOperationsByTag();\n * const servers = api.openapi.getServers();\n * ```\n */\nexport function useOpenAPICombined(\n  input?: OpenAPIV3.Document | string | null | undefined\n): UseOpenAPICombinedResult {\n  // 数据加载层\n  const loader = useOpenAPILoader(input);\n\n  // 数据处理层 - 只有当 spec 存在时才进行处理\n  const openapi = useOpenApi(loader.spec);\n\n  // 返回组合结果\n  return useMemo(() => ({\n    // 直接透传 loader 的所有属性和方法\n    ...loader,\n\n    // 添加 openapi 处理器\n    openapi,\n  }), [loader, openapi]);\n}\n\n/**\n * 便捷的 URL 加载 Hook\n *\n * @example\n * ```tsx\n * const { spec, loading, error, openapi } = useOpenAPIFromUrl(\n *   'https://petstore3.swagger.io/api/v3/openapi.json'\n * );\n *\n * if (loading) return <div>Loading...</div>;\n * if (error) return <div>Error: {error}</div>;\n *\n * const operations = openapi.getOperationsByTag();\n * ```\n */\nexport function useOpenAPIFromUrl(url: string) {\n  return useOpenAPICombined(url);\n}\n\n/**\n * 便捷的字符串解析 Hook\n *\n * @example\n * ```tsx\n * const yamlContent = `\n * openapi: 3.0.0\n * info:\n *   title: My API\n *   version: 1.0.0\n * paths: {}\n * `;\n *\n * const { spec, error, openapi } = useOpenAPIFromString(yamlContent);\n * ```\n */\nexport function useOpenAPIFromString(content: string) {\n  return useOpenAPICombined(content);\n}\n\n/**\n * 便捷的对象 Hook\n *\n * @example\n * ```tsx\n * const spec: OpenAPIV3.Document = { ... };\n * const { openapi } = useOpenAPIFromObject(spec);\n * ```\n */\nexport function useOpenAPIFromObject(spec: OpenAPIV3.Document) {\n  return useOpenAPICombined(spec);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi-combined.ts"
    },
    {
      "path": "registry/default/hooks/use-openapi-loader.ts",
      "content": "\"use client\";\n\nimport * as yaml from \"js-yaml\";\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\n// 数据源类型\nexport type OpenAPISource =\n  | { type: \"object\"; data: OpenAPIV3.Document }\n  | { type: \"string\"; data: string }\n  | { type: \"url\"; data: string };\n\n// Hook 状态\nexport interface UseOpenAPILoaderState {\n  spec: OpenAPIV3.Document | null;\n  loading: boolean;\n  error: string | null;\n}\n\n// Hook 返回值\nexport interface UseOpenAPILoaderResult extends UseOpenAPILoaderState {\n  loadFromUrl: (url: string) => Promise<void>;\n  loadFromString: (content: string) => Promise<void>;\n  loadFromObject: (spec: OpenAPIV3.Document) => void;\n  reload: () => Promise<void>;\n  reset: () => void;\n}\n\n/**\n * 智能判断输入类型并转换为 OpenAPISource\n */\nfunction createOpenAPISource(input: OpenAPIV3.Document | string | null | undefined): OpenAPISource | undefined {\n  if (!input) return undefined;\n\n  if (typeof input === \"string\") {\n    // 检测字符串是否为 URL\n    const isUrl = input.startsWith(\"http://\") || input.startsWith(\"https://\") || input.startsWith(\"/\");\n    return isUrl\n      ? { type: \"url\", data: input }\n      : { type: \"string\", data: input };\n  }\n\n  if (typeof input === \"object\" && input !== null) {\n    return { type: \"object\", data: input };\n  }\n\n  return undefined;\n}\n\n/**\n * OpenAPI 数据加载器 Hook\n * 专门处理数据获取、格式转换和缓存\n * 支持智能判断输入类型\n */\nexport function useOpenAPILoader(\n  input?: OpenAPIV3.Document | string | null | undefined\n): UseOpenAPILoaderResult {\n  const [state, setState] = useState<UseOpenAPILoaderState>({\n    spec: null,\n    loading: false,\n    error: null,\n  });\n\n  const [currentSource, setCurrentSource] = useState<OpenAPISource | null>(null);\n\n  // 智能判断输入并创建数据源\n  const dataSource = useMemo(() => createOpenAPISource(input), [input]);\n\n  // 解析字符串内容（JSON 或 YAML）\n  const parseContent = useCallback((content: string): OpenAPIV3.Document => {\n    // 先尝试 JSON\n    try {\n      return JSON.parse(content);\n    } catch (jsonError) {\n      // JSON 失败，尝试 YAML\n      try {\n        const yamlData = yaml.load(content);\n        if (typeof yamlData === \"object\" && yamlData !== null) {\n          return yamlData as OpenAPIV3.Document;\n        }\n        throw new Error(\"YAML 解析结果不是有效对象\");\n      } catch (yamlError) {\n        throw new Error(\n          `无法解析内容: JSON 错误: ${jsonError instanceof Error ? jsonError.message : \"未知错误\"}, YAML 错误: ${yamlError instanceof Error ? yamlError.message : \"未知错误\"}`\n        );\n      }\n    }\n  }, []);\n\n  // 从 URL 加载\n  const loadFromUrl = useCallback(async (url: string) => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    setCurrentSource({ type: \"url\", data: url });\n\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const content = await response.text();\n      const parsedSpec = parseContent(content);\n\n      setState({\n        spec: parsedSpec,\n        loading: false,\n        error: null,\n      });\n    } catch (error) {\n      setState({\n        spec: null,\n        loading: false,\n        error: error instanceof Error ? error.message : \"加载失败\",\n      });\n    }\n  }, [parseContent]);\n\n  // 从字符串加载\n  const loadFromString = useCallback(async (content: string) => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    setCurrentSource({ type: \"string\", data: content });\n\n    try {\n      const parsedSpec = parseContent(content);\n      setState({\n        spec: parsedSpec,\n        loading: false,\n        error: null,\n      });\n    } catch (error) {\n      setState({\n        spec: null,\n        loading: false,\n        error: error instanceof Error ? error.message : \"解析失败\",\n      });\n    }\n  }, [parseContent]);\n\n  // 从对象加载\n  const loadFromObject = useCallback((spec: OpenAPIV3.Document) => {\n    setCurrentSource({ type: \"object\", data: spec });\n    setState({\n      spec,\n      loading: false,\n      error: null,\n    });\n  }, []);\n\n  // 重新加载当前源\n  const reload = useCallback(async () => {\n    if (!currentSource) return;\n\n    switch (currentSource.type) {\n      case \"url\":\n        await loadFromUrl(currentSource.data);\n        break;\n      case \"string\":\n        await loadFromString(currentSource.data);\n        break;\n      case \"object\":\n        loadFromObject(currentSource.data);\n        break;\n    }\n  }, [currentSource, loadFromUrl, loadFromString, loadFromObject]);\n\n  // 重置状态\n  const reset = useCallback(() => {\n    setState({\n      spec: null,\n      loading: false,\n      error: null,\n    });\n    setCurrentSource(null);\n  }, []);\n\n  // 处理数据源变化\n  useEffect(() => {\n    if (dataSource) {\n      switch (dataSource.type) {\n        case \"url\":\n          loadFromUrl(dataSource.data);\n          break;\n        case \"string\":\n          loadFromString(dataSource.data);\n          break;\n        case \"object\":\n          loadFromObject(dataSource.data);\n          break;\n      }\n    } else {\n      // 如果没有数据源，重置状态\n      reset();\n    }\n  }, [dataSource, loadFromUrl, loadFromString, loadFromObject, reset]);\n\n  return {\n    ...state,\n    loadFromUrl,\n    loadFromString,\n    loadFromObject,\n    reload,\n    reset,\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi-loader.ts"
    },
    {
      "path": "registry/default/hooks/use-openapi.ts",
      "content": "\"use client\";\n\nimport { resolveRef } from \"@/registry/default/lib/resolve-ref\";\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useMemo } from \"react\";\n\n/**\n * 自定义钩子，简化OpenAPI结构的处理\n * @param spec OpenAPI规范对象或null\n * @returns 一组处理OpenAPI结构的工具函数\n */\nexport function useOpenApi(spec: OpenAPIV3.Document | null, components?: OpenAPIV3.ComponentsObject) {\n  // 优先使用传入的components，如果没有则使用spec中的components\n  const effectiveComponents = components || spec?.components;\n\n  // 优化引用解析，避免重复计算\n  const resolve = useMemo(() => {\n    return function resolve<T>(\n      obj: T | OpenAPIV3.ReferenceObject | undefined,\n      category?: string,\n    ): T | null {\n      if (!effectiveComponents) return null;\n      return resolveRef<T>(obj, effectiveComponents, category);\n    };\n  }, [effectiveComponents]);\n\n  /**\n   * 获取模式的类型信息\n   */\n  const getSchemaType = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ): string => {\n    if (!schema) return \"未知\";\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return \"未知\";\n\n    let type = resolvedSchema.type || \"\";\n\n    // 处理数组类型\n    if (type === \"array\" && \"items\" in resolvedSchema && resolvedSchema.items) {\n      const itemType = getSchemaType(resolvedSchema.items);\n      return `${type}<${itemType}>`;\n    }\n\n    // 处理对象或复合类型\n    if (type === \"object\" || !type) {\n      if (resolvedSchema.properties) return \"object\";\n      if (resolvedSchema.allOf) return \"allOf\";\n      if (resolvedSchema.oneOf) return \"oneOf\";\n      if (resolvedSchema.anyOf) return \"anyOf\";\n    }\n\n    // 处理格式化的类型\n    if (resolvedSchema.format) {\n      return `${type}(${resolvedSchema.format})`;\n    }\n\n    return type || \"未知\";\n  };\n\n  /**\n   * 从请求体中获取模式对象\n   */\n  const getRequestBodySchema = (\n    requestBody: OpenAPIV3.RequestBodyObject | OpenAPIV3.ReferenceObject | undefined,\n  ): OpenAPIV3.SchemaObject | null => {\n    if (!requestBody) return null;\n\n    const resolvedBody = resolve<OpenAPIV3.RequestBodyObject>(requestBody, \"requestBodies\");\n    if (!resolvedBody?.content) return null;\n\n    // 尝试获取常见内容类型\n    const contentTypes = [\"application/json\", \"application/xml\", \"*/*\"];\n    for (const contentType of contentTypes) {\n      const schema = resolvedBody.content[contentType]?.schema;\n      if (schema) {\n        return resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n      }\n    }\n\n    // 如果找不到常见类型，使用第一个可用类型\n    const firstContentType = Object.keys(resolvedBody.content)[0];\n    if (firstContentType) {\n      const schema = resolvedBody.content[firstContentType]?.schema;\n      if (schema) {\n        return resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * 获取模式的属性信息\n   */\n  const getSchemaProperties = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!schema) return {};\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return {};\n\n    // 处理基本对象\n    if (resolvedSchema.properties) {\n      return resolvedSchema.properties;\n    }\n\n    // 处理数组\n    if (resolvedSchema.type === \"array\" && \"items\" in resolvedSchema && resolvedSchema.items) {\n      const itemsSchema = resolve<OpenAPIV3.SchemaObject>(resolvedSchema.items, \"schemas\");\n      return itemsSchema?.properties || {};\n    }\n\n    // 处理组合模式\n    if (resolvedSchema.allOf) {\n      const mergedProperties = {};\n      for (const subSchema of resolvedSchema.allOf) {\n        Object.assign(mergedProperties, getSchemaProperties(subSchema));\n      }\n      return mergedProperties;\n    }\n\n    return {};\n  };\n\n  /**\n   * 处理参数集合，按位置分组\n   */\n  const processParameters = (\n    parameters: (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[] | undefined,\n  ) => {\n    if (!parameters?.length) return {};\n\n    const result: Record<string, (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[]> = {\n      path: [],\n      query: [],\n      header: [],\n      cookie: [],\n    };\n\n    for (const param of parameters) {\n      const resolvedParam = resolve<OpenAPIV3.ParameterObject>(param, \"parameters\");\n      if (resolvedParam?.in && resolvedParam.in in result) {\n        result[resolvedParam.in].push(resolvedParam);\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * 处理响应对象\n   */\n  const processResponse = (\n    response: OpenAPIV3.ResponseObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!response) return null;\n\n    const resolvedResponse = resolve<OpenAPIV3.ResponseObject>(response, \"responses\");\n    if (!resolvedResponse) return null;\n\n    return {\n      description: resolvedResponse.description || \"\",\n      headers: resolvedResponse.headers || {},\n      content: resolvedResponse.content || {},\n    };\n  };\n\n  /**\n   * 获取模式的约束条件\n   */\n  const getSchemaConstraints = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!schema) return {};\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return {};\n\n    const constraints: Record<string, any> = {};\n\n    // 数值约束\n    if (typeof resolvedSchema.minimum === \"number\") constraints.minimum = resolvedSchema.minimum;\n    if (typeof resolvedSchema.maximum === \"number\") constraints.maximum = resolvedSchema.maximum;\n    if (typeof resolvedSchema.exclusiveMinimum === \"number\") constraints.exclusiveMinimum = resolvedSchema.exclusiveMinimum;\n    if (typeof resolvedSchema.exclusiveMaximum === \"number\") constraints.exclusiveMaximum = resolvedSchema.exclusiveMaximum;\n    if (typeof resolvedSchema.multipleOf === \"number\") constraints.multipleOf = resolvedSchema.multipleOf;\n\n    // 字符串约束\n    if (typeof resolvedSchema.minLength === \"number\") constraints.minLength = resolvedSchema.minLength;\n    if (typeof resolvedSchema.maxLength === \"number\") constraints.maxLength = resolvedSchema.maxLength;\n    if (resolvedSchema.pattern) constraints.pattern = resolvedSchema.pattern;\n\n    // 数组约束\n    if (typeof resolvedSchema.minItems === \"number\") constraints.minItems = resolvedSchema.minItems;\n    if (typeof resolvedSchema.maxItems === \"number\") constraints.maxItems = resolvedSchema.maxItems;\n    if (resolvedSchema.uniqueItems) constraints.uniqueItems = resolvedSchema.uniqueItems;\n\n    // 对象约束\n    if (typeof resolvedSchema.minProperties === \"number\") constraints.minProperties = resolvedSchema.minProperties;\n    if (typeof resolvedSchema.maxProperties === \"number\") constraints.maxProperties = resolvedSchema.maxProperties;\n\n    return constraints;\n  };\n\n  /**\n   * 获取指定路径和方法的操作对象\n   */\n  const getOperation = (path: string, method: string): OpenAPIV3.OperationObject | null => {\n    if (!spec?.paths?.[path]) return null;\n\n    const pathItem = spec.paths[path] as OpenAPIV3.PathItemObject;\n    const operation = pathItem[method.toLowerCase() as keyof OpenAPIV3.PathItemObject];\n\n    if (operation && typeof operation === \"object\" && \"responses\" in operation) {\n      return operation as OpenAPIV3.OperationObject;\n    }\n\n    return null;\n  };\n\n  /**\n   * 获取服务器列表\n   */\n  const getServers = (): OpenAPIV3.ServerObject[] => {\n    return spec?.servers || [];\n  };\n\n  // 提取 HTTP 方法列表\n  const HTTP_METHODS = [\"get\", \"post\", \"put\", \"delete\", \"patch\", \"head\", \"options\", \"trace\"] as const;\n\n  /**\n   * 按标签分组获取操作\n   */\n  const getOperationsByTag = () => {\n    if (!spec?.paths) return {};\n\n    const operations: Record<string, Array<{\n      path: string;\n      method: string;\n      operation: OpenAPIV3.OperationObject;\n    }>> = {};\n\n    Object.entries(spec.paths).forEach(([path, pathItem]) => {\n      if (!pathItem || typeof pathItem !== \"object\") return;\n\n      HTTP_METHODS.forEach((method) => {\n        const operation = pathItem[method];\n        if (operation && typeof operation === \"object\" && \"responses\" in operation) {\n          const op = operation as OpenAPIV3.OperationObject;\n          const tags = op.tags || [\"default\"];\n\n          tags.forEach((tag) => {\n            if (!operations[tag]) {\n              operations[tag] = [];\n            }\n            operations[tag].push({\n              path,\n              method: method.toUpperCase(),\n              operation: op,\n            });\n          });\n        }\n      });\n    });\n\n    return operations;\n  };\n\n  /**\n   * 获取所有标签\n   */\n  const getTags = () => {\n    return spec?.tags || [];\n  };\n\n  /**\n   * 获取API信息\n   */\n  const getInfo = () => {\n    return spec?.info || null;\n  };\n\n  /**\n   * 获取组件定义\n   */\n  const getComponents = () => {\n    return effectiveComponents || null;\n  };\n\n  return {\n    // 原始数据\n    spec,\n    components: effectiveComponents,\n\n    // 状态检查\n    hasComponents: !!effectiveComponents,\n\n    // 解析函数\n    resolve,\n\n    // 模式处理\n    getSchemaType,\n    getSchemaProperties,\n    getSchemaConstraints,\n    getRequestBodySchema,\n\n    // 参数和响应处理\n    processParameters,\n    processResponse,\n\n    // 操作处理\n    getOperation,\n    getOperationsByTag,\n    getTags,\n\n    // 服务器和基本信息\n    getServers,\n    getInfo,\n    getComponents,\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi.ts"
    },
    {
      "path": "registry/default/hooks/use-operation.ts",
      "content": "\"use client\";\n\nimport { useMemo } from \"react\";\n\n/**\n * Hook for working with OpenAPI operations\n * @param operation - The operation object\n * @param path - The path string\n * @param method - The HTTP method\n * @returns Operation utilities\n */\nexport function useOperation(operation: any, path: string, method: string) {\n  return useMemo(() => {\n    const getOperationId = () => {\n      return operation.operationId || `${method.toLowerCase()}-${path}`;\n    };\n\n    const getTags = () => {\n      return operation.tags || [];\n    };\n\n    const getParameters = () => {\n      return operation.parameters || [];\n    };\n\n    const getRequestBody = () => {\n      return operation.requestBody;\n    };\n\n    const getResponses = () => {\n      return operation.responses || {};\n    };\n\n    const getSecurity = () => {\n      return operation.security || [];\n    };\n\n    return {\n      getOperationId,\n      getTags,\n      getParameters,\n      getRequestBody,\n      getResponses,\n      getSecurity,\n    };\n  }, [operation, path, method]);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-operation.ts"
    },
    {
      "path": "registry/default/hooks/use-schema.ts",
      "content": "\"use client\";\n\nimport { resolveRef } from \"@/registry/default/lib/resolve-ref\";\nimport { useMemo } from \"react\";\n\n/**\n * Hook for working with OpenAPI schemas\n * @param schema - The schema object or reference\n * @param components - The components object containing schemas\n * @returns Resolved schema and utility functions\n */\nexport function useSchema(schema: any, components: any) {\n  return useMemo(() => {\n    const resolvedSchema = schema.$ref\n      ? resolveRef(schema, components)\n      : schema;\n\n    const getType = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\")\n        return \"unknown\";\n      return resolvedSchema.type || \"object\";\n    };\n\n    const isRequired = (propertyName: string) => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\") return false;\n      return resolvedSchema.required?.includes(propertyName) || false;\n    };\n\n    const getProperties = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\") return {};\n      return resolvedSchema.properties || {};\n    };\n\n    return {\n      resolvedSchema,\n      getType,\n      isRequired,\n      getProperties,\n    };\n  }, [schema, components]);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-schema.ts"
    }
  ]
}