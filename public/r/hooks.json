{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "hooks",
  "type": "registry:hook",
  "description": "React hooks collection",
  "dependencies": [
    "js-yaml",
    "openapi-types",
    "react"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-openapi-combined.ts",
      "content": "\"use client\";\n\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useMemo } from \"react\";\nimport { useOpenApi } from \"./use-openapi\";\nimport { useOpenAPILoader, type OpenAPISource } from \"./use-openapi-loader\";\n\n// 组合 Hook 的返回类型\nexport interface UseOpenAPICombinedResult {\n  // 来自 loader 的状态和方法\n  spec: OpenAPIV3.Document | null;\n  loading: boolean;\n  error: string | null;\n  loadFromUrl: (url: string) => Promise<void>;\n  loadFromString: (content: string) => Promise<void>;\n  loadFromObject: (spec: OpenAPIV3.Document) => void;\n  reload: () => Promise<void>;\n  reset: () => void;\n\n  // 来自 openapi 的处理方法\n  openapi: ReturnType<typeof useOpenApi>;\n}\n\n/**\n * 组合 Hook - 整合数据加载和数据处理\n *\n * 这个 Hook 展示了如何正确地组合使用：\n * - useOpenAPILoader: 专门处理数据获取和格式转换\n * - useOpenApi: 专门处理已解析数据的结构操作\n *\n * @example\n * ```tsx\n * // 基础使用\n * const api = useOpenAPICombined();\n *\n * // 加载数据\n * await api.loadFromUrl('https://api.example.com/openapi.json');\n *\n * // 使用处理方法\n * const operations = api.openapi.getOperationsByTag();\n * const servers = api.openapi.getServers();\n * ```\n */\nexport function useOpenAPICombined(\n  initialSource?: OpenAPISource\n): UseOpenAPICombinedResult {\n  // 数据加载层\n  const loader = useOpenAPILoader(initialSource);\n\n  // 数据处理层 - 只有当 spec 存在时才进行处理\n  const openapi = useOpenApi(loader.spec);\n\n  // 返回组合结果\n  return useMemo(() => ({\n    // 直接透传 loader 的所有属性和方法\n    ...loader,\n\n    // 添加 openapi 处理器\n    openapi,\n  }), [loader, openapi]);\n}\n\n/**\n * 便捷的 URL 加载 Hook\n *\n * @example\n * ```tsx\n * const { spec, loading, error, openapi } = useOpenAPIFromUrl(\n *   'https://petstore3.swagger.io/api/v3/openapi.json'\n * );\n *\n * if (loading) return <div>Loading...</div>;\n * if (error) return <div>Error: {error}</div>;\n *\n * const operations = openapi.getOperationsByTag();\n * ```\n */\nexport function useOpenAPIFromUrl(url: string) {\n  return useOpenAPICombined({ type: \"url\", data: url });\n}\n\n/**\n * 便捷的字符串解析 Hook\n *\n * @example\n * ```tsx\n * const yamlContent = `\n * openapi: 3.0.0\n * info:\n *   title: My API\n *   version: 1.0.0\n * paths: {}\n * `;\n *\n * const { spec, error, openapi } = useOpenAPIFromString(yamlContent);\n * ```\n */\nexport function useOpenAPIFromString(content: string) {\n  return useOpenAPICombined({ type: \"string\", data: content });\n}\n\n/**\n * 便捷的对象 Hook\n *\n * @example\n * ```tsx\n * const spec: OpenAPIV3.Document = { ... };\n * const { openapi } = useOpenAPIFromObject(spec);\n * ```\n */\nexport function useOpenAPIFromObject(spec: OpenAPIV3.Document) {\n  return useOpenAPICombined({ type: \"object\", data: spec });\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi-combined.ts"
    },
    {
      "path": "registry/default/hooks/use-openapi-loader.ts",
      "content": "\"use client\";\n\nimport * as yaml from \"js-yaml\";\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useCallback, useEffect, useState } from \"react\";\n\n// 数据源类型\nexport type OpenAPISource =\n  | { type: \"object\"; data: OpenAPIV3.Document }\n  | { type: \"string\"; data: string }\n  | { type: \"url\"; data: string };\n\n// Hook 状态\nexport interface UseOpenAPILoaderState {\n  spec: OpenAPIV3.Document | null;\n  loading: boolean;\n  error: string | null;\n}\n\n// Hook 返回值\nexport interface UseOpenAPILoaderResult extends UseOpenAPILoaderState {\n  loadFromUrl: (url: string) => Promise<void>;\n  loadFromString: (content: string) => Promise<void>;\n  loadFromObject: (spec: OpenAPIV3.Document) => void;\n  reload: () => Promise<void>;\n  reset: () => void;\n}\n\n/**\n * OpenAPI 数据加载器 Hook\n * 专门处理数据获取、格式转换和缓存\n */\nexport function useOpenAPILoader(\n  initialSource?: OpenAPISource\n): UseOpenAPILoaderResult {\n  const [state, setState] = useState<UseOpenAPILoaderState>({\n    spec: null,\n    loading: false,\n    error: null,\n  });\n\n  const [currentSource, setCurrentSource] = useState<OpenAPISource | null>(\n    initialSource || null\n  );\n\n  // 解析字符串内容（JSON 或 YAML）\n  const parseContent = useCallback((content: string): OpenAPIV3.Document => {\n    // 先尝试 JSON\n    try {\n      return JSON.parse(content);\n    } catch (jsonError) {\n      // JSON 失败，尝试 YAML\n      try {\n        const yamlData = yaml.load(content);\n        if (typeof yamlData === \"object\" && yamlData !== null) {\n          return yamlData as OpenAPIV3.Document;\n        }\n        throw new Error(\"YAML 解析结果不是有效对象\");\n      } catch (yamlError) {\n        throw new Error(\n          `无法解析内容: JSON 错误: ${jsonError instanceof Error ? jsonError.message : \"未知错误\"}, YAML 错误: ${yamlError instanceof Error ? yamlError.message : \"未知错误\"}`\n        );\n      }\n    }\n  }, []);\n\n  // 从 URL 加载\n  const loadFromUrl = useCallback(async (url: string) => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    setCurrentSource({ type: \"url\", data: url });\n\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const content = await response.text();\n      const parsedSpec = parseContent(content);\n\n      setState({\n        spec: parsedSpec,\n        loading: false,\n        error: null,\n      });\n    } catch (error) {\n      setState({\n        spec: null,\n        loading: false,\n        error: error instanceof Error ? error.message : \"加载失败\",\n      });\n    }\n  }, [parseContent]);\n\n  // 从字符串加载\n  const loadFromString = useCallback(async (content: string) => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    setCurrentSource({ type: \"string\", data: content });\n\n    try {\n      const parsedSpec = parseContent(content);\n      setState({\n        spec: parsedSpec,\n        loading: false,\n        error: null,\n      });\n    } catch (error) {\n      setState({\n        spec: null,\n        loading: false,\n        error: error instanceof Error ? error.message : \"解析失败\",\n      });\n    }\n  }, [parseContent]);\n\n  // 从对象加载\n  const loadFromObject = useCallback((spec: OpenAPIV3.Document) => {\n    setCurrentSource({ type: \"object\", data: spec });\n    setState({\n      spec,\n      loading: false,\n      error: null,\n    });\n  }, []);\n\n  // 重新加载当前源\n  const reload = useCallback(async () => {\n    if (!currentSource) return;\n\n    switch (currentSource.type) {\n      case \"url\":\n        await loadFromUrl(currentSource.data);\n        break;\n      case \"string\":\n        await loadFromString(currentSource.data);\n        break;\n      case \"object\":\n        loadFromObject(currentSource.data);\n        break;\n    }\n  }, [currentSource, loadFromUrl, loadFromString, loadFromObject]);\n\n  // 重置状态\n  const reset = useCallback(() => {\n    setState({\n      spec: null,\n      loading: false,\n      error: null,\n    });\n    setCurrentSource(null);\n  }, []);\n\n  // 初始化加载\n  useEffect(() => {\n    if (initialSource) {\n      switch (initialSource.type) {\n        case \"url\":\n          loadFromUrl(initialSource.data);\n          break;\n        case \"string\":\n          loadFromString(initialSource.data);\n          break;\n        case \"object\":\n          loadFromObject(initialSource.data);\n          break;\n      }\n    }\n  }, []); // 只在挂载时执行\n\n  return {\n    ...state,\n    loadFromUrl,\n    loadFromString,\n    loadFromObject,\n    reload,\n    reset,\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi-loader.ts"
    },
    {
      "path": "registry/default/hooks/use-openapi.ts",
      "content": "\"use client\";\n\nimport { resolveRef } from \"@/registry/default/lib/resolve-ref\";\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { useMemo } from \"react\";\n\n/**\n * 自定义钩子，简化OpenAPI结构的处理\n * @param spec OpenAPI规范对象或null\n * @returns 一组处理OpenAPI结构的工具函数\n */\nexport function useOpenApi(spec: OpenAPIV3.Document | null) {\n  // 当spec为null时，返回空的组件\n  const components = spec?.components;\n\n  // 优化引用解析，避免重复计算\n  const resolve = useMemo(() => {\n    return function resolve<T>(\n      obj: T | OpenAPIV3.ReferenceObject | undefined,\n      category?: string,\n    ): T | null {\n      if (!spec || !components) return null;\n      return resolveRef<T>(obj, components, category);\n    };\n  }, [components, spec]);\n\n  /**\n   * 获取模式的类型信息\n   * @param schema 模式对象\n   * @returns 类型信息字符串\n   */\n  const getSchemaType = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ): string => {\n    if (!schema) return \"未知\";\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return \"未知\";\n\n    let type = resolvedSchema.type || \"\";\n\n    // 处理数组类型\n    if (type === \"array\" && \"items\" in resolvedSchema && resolvedSchema.items) {\n      const itemType = getSchemaType(resolvedSchema.items);\n      return `${type}<${itemType}>`;\n    }\n\n    // 处理对象或复合类型\n    if (type === \"object\" || !type) {\n      if (resolvedSchema.properties) {\n        return \"object\";\n      }\n      if (resolvedSchema.allOf) {\n        return \"allOf\";\n      }\n      if (resolvedSchema.oneOf) {\n        return \"oneOf\";\n      }\n      if (resolvedSchema.anyOf) {\n        return \"anyOf\";\n      }\n    }\n\n    // 处理格式化的类型\n    if (resolvedSchema.format) {\n      return `${type}(${resolvedSchema.format})`;\n    }\n\n    return type || \"未知\";\n  };\n\n  /**\n   * 从请求体中获取模式对象\n   * @param requestBody 请求体对象\n   * @returns 解析后的模式对象\n   */\n  const getRequestBodySchema = (\n    requestBody:\n      | OpenAPIV3.RequestBodyObject\n      | OpenAPIV3.ReferenceObject\n      | undefined,\n  ): OpenAPIV3.SchemaObject | null => {\n    if (!requestBody) return null;\n\n    const resolvedBody = resolve<OpenAPIV3.RequestBodyObject>(\n      requestBody,\n      \"requestBodies\",\n    );\n    if (!resolvedBody || !resolvedBody.content) return null;\n\n    // 尝试获取常见内容类型\n    const contentTypes = [\"application/json\", \"application/xml\", \"*/*\"];\n    for (const contentType of contentTypes) {\n      if (resolvedBody.content[contentType]?.schema) {\n        return (\n          resolve<OpenAPIV3.SchemaObject>(\n            resolvedBody.content[contentType].schema,\n            \"schemas\",\n          ) || null\n        );\n      }\n    }\n\n    // 如果找不到常见类型，使用第一个可用类型\n    const firstContentType = Object.keys(resolvedBody.content)[0];\n    if (firstContentType && resolvedBody.content[firstContentType]?.schema) {\n      return (\n        resolve<OpenAPIV3.SchemaObject>(\n          resolvedBody.content[firstContentType].schema,\n          \"schemas\",\n        ) || null\n      );\n    }\n\n    return null;\n  };\n\n  /**\n   * 获取模式的属性信息\n   * @param schema 模式对象\n   * @returns 属性对象集合\n   */\n  const getSchemaProperties = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!schema) return {};\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return {};\n\n    // 处理基本对象\n    if (resolvedSchema.properties) {\n      return resolvedSchema.properties;\n    }\n\n    // 处理数组\n    if (\n      resolvedSchema.type === \"array\" &&\n      \"items\" in resolvedSchema &&\n      resolvedSchema.items\n    ) {\n      const itemsSchema = resolve<OpenAPIV3.SchemaObject>(\n        resolvedSchema.items,\n        \"schemas\",\n      );\n      if (itemsSchema?.properties) {\n        return itemsSchema.properties;\n      }\n    }\n\n    // 处理组合模式\n    if (resolvedSchema.allOf) {\n      // 合并所有allOf模式的属性\n      const mergedProperties = {};\n      for (const subSchema of resolvedSchema.allOf) {\n        const subProperties = getSchemaProperties(subSchema);\n        Object.assign(mergedProperties, subProperties);\n      }\n      return mergedProperties;\n    }\n\n    return {};\n  };\n\n  /**\n   * 处理参数集合，按位置分组\n   * @param parameters 参数对象数组\n   * @returns 按位置分组的参数\n   */\n  const processParameters = (\n    parameters:\n      | (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[]\n      | undefined,\n  ) => {\n    if (!parameters || parameters.length === 0) {\n      return {};\n    }\n\n    const result: {\n      [key: string]: (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[];\n    } = {\n      path: [],\n      query: [],\n      header: [],\n      cookie: [],\n    };\n\n    for (const param of parameters) {\n      const resolvedParam = resolve<OpenAPIV3.ParameterObject>(\n        param,\n        \"parameters\",\n      );\n      if (resolvedParam && resolvedParam.in) {\n        const paramIn = resolvedParam.in as keyof typeof result;\n        if (paramIn in result && result[paramIn]) {\n          result[paramIn].push(resolvedParam);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * 处理响应对象\n   * @param response 响应对象\n   * @returns 处理后的响应对象\n   */\n  const processResponse = (\n    response: OpenAPIV3.ResponseObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!response) return null;\n\n    const resolvedResponse = resolve<OpenAPIV3.ResponseObject>(\n      response,\n      \"responses\",\n    );\n    if (!resolvedResponse) return null;\n\n    const result = {\n      description: resolvedResponse.description || \"\",\n      headers: resolvedResponse.headers || {},\n      content: resolvedResponse.content || {},\n    };\n\n    return result;\n  };\n\n  /**\n   * 获取模式的约束条件\n   * @param schema 模式对象\n   * @returns 约束条件对象\n   */\n  const getSchemaConstraints = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!schema) return {};\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return {};\n\n    const constraints: { [key: string]: any } = {};\n\n    // 数值约束\n    if (typeof resolvedSchema.minimum === \"number\") {\n      constraints.minimum = resolvedSchema.minimum;\n    }\n    if (typeof resolvedSchema.maximum === \"number\") {\n      constraints.maximum = resolvedSchema.maximum;\n    }\n    if (typeof resolvedSchema.exclusiveMinimum === \"number\") {\n      constraints.exclusiveMinimum = resolvedSchema.exclusiveMinimum;\n    }\n    if (typeof resolvedSchema.exclusiveMaximum === \"number\") {\n      constraints.exclusiveMaximum = resolvedSchema.exclusiveMaximum;\n    }\n    if (typeof resolvedSchema.multipleOf === \"number\") {\n      constraints.multipleOf = resolvedSchema.multipleOf;\n    }\n\n    // 字符串约束\n    if (typeof resolvedSchema.minLength === \"number\") {\n      constraints.minLength = resolvedSchema.minLength;\n    }\n    if (typeof resolvedSchema.maxLength === \"number\") {\n      constraints.maxLength = resolvedSchema.maxLength;\n    }\n    if (resolvedSchema.pattern) {\n      constraints.pattern = resolvedSchema.pattern;\n    }\n\n    // 数组约束\n    if (typeof resolvedSchema.minItems === \"number\") {\n      constraints.minItems = resolvedSchema.minItems;\n    }\n    if (typeof resolvedSchema.maxItems === \"number\") {\n      constraints.maxItems = resolvedSchema.maxItems;\n    }\n    if (resolvedSchema.uniqueItems) {\n      constraints.uniqueItems = resolvedSchema.uniqueItems;\n    }\n\n    // 对象约束\n    if (typeof resolvedSchema.minProperties === \"number\") {\n      constraints.minProperties = resolvedSchema.minProperties;\n    }\n    if (typeof resolvedSchema.maxProperties === \"number\") {\n      constraints.maxProperties = resolvedSchema.maxProperties;\n    }\n\n    return constraints;\n  };\n\n  /**\n   * 获取指定路径和方法的操作对象\n   * @param path 路径\n   * @param method HTTP方法\n   * @returns 操作对象\n   */\n  const getOperation = (\n    path: string,\n    method: string,\n  ): OpenAPIV3.OperationObject | null => {\n    if (!spec || !spec.paths || !spec.paths[path]) {\n      return null;\n    }\n\n    const pathItem = spec.paths[path] as OpenAPIV3.PathItemObject;\n    const operation =\n      pathItem[method.toLowerCase() as keyof OpenAPIV3.PathItemObject];\n\n    if (\n      operation &&\n      typeof operation === \"object\" &&\n      \"responses\" in operation\n    ) {\n      return operation as OpenAPIV3.OperationObject;\n    }\n\n    return null;\n  };\n\n  /**\n   * 获取服务器列表\n   * @returns 服务器对象数组\n   */\n  const getServers = (): OpenAPIV3.ServerObject[] => {\n    return spec?.servers || [];\n  };\n\n  /**\n   * 按标签分组获取操作\n   * @returns 按标签分组的操作对象\n   */\n  const getOperationsByTag = () => {\n    if (!spec || !spec.paths) {\n      return {};\n    }\n\n    const operations: {\n      [tag: string]: Array<{\n        path: string;\n        method: string;\n        operation: OpenAPIV3.OperationObject;\n      }>;\n    } = {};\n\n    Object.entries(spec.paths).forEach(([path, pathItem]) => {\n      if (!pathItem || typeof pathItem !== \"object\") return;\n\n      const methods = [\n        \"get\",\n        \"post\",\n        \"put\",\n        \"delete\",\n        \"patch\",\n        \"head\",\n        \"options\",\n        \"trace\",\n      ];\n\n      methods.forEach((method) => {\n        const operation = pathItem[method as keyof OpenAPIV3.PathItemObject];\n        if (\n          operation &&\n          typeof operation === \"object\" &&\n          \"responses\" in operation\n        ) {\n          const op = operation as OpenAPIV3.OperationObject;\n          const tags = op.tags || [\"default\"];\n\n          tags.forEach((tag) => {\n            if (!operations[tag]) {\n              operations[tag] = [];\n            }\n            operations[tag].push({\n              path,\n              method: method.toUpperCase(),\n              operation: op,\n            });\n          });\n        }\n      });\n    });\n\n    return operations;\n  };\n\n  /**\n   * 获取所有标签\n   * @returns 标签数组\n   */\n  const getTags = () => {\n    if (!spec) return [];\n    return spec.tags || [];\n  };\n\n  /**\n   * 获取API信息\n   * @returns API信息对象\n   */\n  const getInfo = () => {\n    return spec?.info || null;\n  };\n\n  /**\n   * 获取组件定义\n   * @returns 组件对象\n   */\n  const getComponents = () => {\n    return spec?.components || null;\n  };\n\n  return {\n    // 原始数据\n    spec,\n    components,\n\n    // 解析函数\n    resolve,\n\n    // 模式处理\n    getSchemaType,\n    getSchemaProperties,\n    getSchemaConstraints,\n    getRequestBodySchema,\n\n    // 参数和响应处理\n    processParameters,\n    processResponse,\n\n    // 操作处理\n    getOperation,\n    getOperationsByTag,\n    getTags,\n\n    // 服务器和基本信息\n    getServers,\n    getInfo,\n    getComponents,\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-openapi.ts"
    },
    {
      "path": "registry/default/hooks/use-operation.ts",
      "content": "\"use client\";\n\nimport { useMemo } from \"react\";\n\n/**\n * Hook for working with OpenAPI operations\n * @param operation - The operation object\n * @param path - The path string\n * @param method - The HTTP method\n * @returns Operation utilities\n */\nexport function useOperation(operation: any, path: string, method: string) {\n  return useMemo(() => {\n    const getOperationId = () => {\n      return operation.operationId || `${method.toLowerCase()}-${path}`;\n    };\n\n    const getTags = () => {\n      return operation.tags || [];\n    };\n\n    const getParameters = () => {\n      return operation.parameters || [];\n    };\n\n    const getRequestBody = () => {\n      return operation.requestBody;\n    };\n\n    const getResponses = () => {\n      return operation.responses || {};\n    };\n\n    const getSecurity = () => {\n      return operation.security || [];\n    };\n\n    return {\n      getOperationId,\n      getTags,\n      getParameters,\n      getRequestBody,\n      getResponses,\n      getSecurity,\n    };\n  }, [operation, path, method]);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-operation.ts"
    },
    {
      "path": "registry/default/hooks/use-schema.ts",
      "content": "\"use client\";\n\nimport { resolveRef } from \"@/registry/default/lib/resolve-ref\";\nimport { useMemo } from \"react\";\n\n/**\n * Hook for working with OpenAPI schemas\n * @param schema - The schema object or reference\n * @param components - The components object containing schemas\n * @returns Resolved schema and utility functions\n */\nexport function useSchema(schema: any, components: any) {\n  return useMemo(() => {\n    const resolvedSchema = schema.$ref\n      ? resolveRef(schema, components)\n      : schema;\n\n    const getType = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\")\n        return \"unknown\";\n      return resolvedSchema.type || \"object\";\n    };\n\n    const isRequired = (propertyName: string) => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\") return false;\n      return resolvedSchema.required?.includes(propertyName) || false;\n    };\n\n    const getProperties = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== \"object\") return {};\n      return resolvedSchema.properties || {};\n    };\n\n    return {\n      resolvedSchema,\n      getType,\n      isRequired,\n      getProperties,\n    };\n  }, [schema, components]);\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-schema.ts"
    }
  ]
}