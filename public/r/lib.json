{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "lib",
  "type": "registry:lib",
  "description": "Core library components and utilities",
  "dependencies": [
    "@faker-js/faker",
    "openapi-types",
    "react"
  ],
  "files": [
    {
      "path": "registry/lib/hooks/use-openapi.ts",
      "content": "\nimport { resolveRef } from \"@/registry/lib/utils/resolve-ref\";\nimport type { OpenAPIV3 } from 'openapi-types';\nimport { useMemo } from \"react\";\n\n/**\n * 自定义钩子，简化OpenAPI结构的处理\n * @param spec OpenAPI规范对象或null\n * @returns 一组处理OpenAPI结构的工具函数\n */\nexport function useOpenApi(spec: OpenAPIV3.Document | null) {\n  // 当spec为null时，返回空的组件\n  const components = spec?.components;\n\n  // 优化引用解析，避免重复计算\n  const resolve = useMemo(() => {\n    return function resolve<T>(\n      obj: T | OpenAPIV3.ReferenceObject | undefined,\n      category?: string,\n    ): T | null {\n      if (!spec || !components) return null;\n      return resolveRef<T>(obj, components, category);\n    };\n  }, [components, spec]);\n\n  /**\n   * 获取模式的类型信息\n   * @param schema 模式对象\n   * @returns 类型信息字符串\n   */\n  const getSchemaType = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ): string => {\n    if (!schema) return \"未知\";\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return \"未知\";\n\n    let type = resolvedSchema.type || \"\";\n\n    // 处理数组类型\n    if (type === \"array\" && 'items' in resolvedSchema && resolvedSchema.items) {\n      const itemType = getSchemaType(resolvedSchema.items);\n      return `${type}<${itemType}>`;\n    }\n\n    // 处理对象或复合类型\n    if (type === \"object\" || !type) {\n      if (resolvedSchema.properties) {\n        return \"object\";\n      }\n      if (resolvedSchema.allOf) {\n        return \"allOf\";\n      }\n      if (resolvedSchema.oneOf) {\n        return \"oneOf\";\n      }\n      if (resolvedSchema.anyOf) {\n        return \"anyOf\";\n      }\n    }\n\n    // 处理格式化的类型\n    if (resolvedSchema.format) {\n      return `${type}(${resolvedSchema.format})`;\n    }\n\n    return type || \"未知\";\n  };\n\n  /**\n   * 从请求体中获取模式对象\n   * @param requestBody 请求体对象\n   * @returns 解析后的模式对象\n   */\n  const getRequestBodySchema = (\n    requestBody: OpenAPIV3.RequestBodyObject | OpenAPIV3.ReferenceObject | undefined,\n  ): OpenAPIV3.SchemaObject | null => {\n    if (!requestBody) return null;\n\n    const resolvedBody = resolve<OpenAPIV3.RequestBodyObject>(\n      requestBody,\n      \"requestBodies\",\n    );\n    if (!resolvedBody || !resolvedBody.content) return null;\n\n    // 尝试获取常见内容类型\n    const contentTypes = [\"application/json\", \"application/xml\", \"*/*\"];\n    for (const contentType of contentTypes) {\n      if (resolvedBody.content[contentType]?.schema) {\n        return (\n          resolve<OpenAPIV3.SchemaObject>(\n            resolvedBody.content[contentType].schema,\n            \"schemas\",\n          ) || null\n        );\n      }\n    }\n\n    // 如果找不到常见类型，使用第一个可用类型\n    const firstContentType = Object.keys(resolvedBody.content)[0];\n    if (firstContentType && resolvedBody.content[firstContentType]?.schema) {\n      return (\n        resolve<OpenAPIV3.SchemaObject>(\n          resolvedBody.content[firstContentType].schema,\n          \"schemas\",\n        ) || null\n      );\n    }\n\n    return null;\n  };\n\n  /**\n   * 获取模式的属性信息\n   * @param schema 模式对象\n   * @returns 属性对象集合\n   */\n  const getSchemaProperties = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!schema) return {};\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return {};\n\n    // 处理基本对象\n    if (resolvedSchema.properties) {\n      return resolvedSchema.properties;\n    }\n\n    // 处理数组\n    if (resolvedSchema.type === \"array\" && 'items' in resolvedSchema && resolvedSchema.items) {\n      const itemsSchema = resolve<OpenAPIV3.SchemaObject>(\n        resolvedSchema.items,\n        \"schemas\",\n      );\n      if (itemsSchema?.properties) {\n        return itemsSchema.properties;\n      }\n    }\n\n    // 处理组合模式\n    if (resolvedSchema.allOf) {\n      // 合并所有allOf模式的属性\n      const mergedProperties = {};\n      for (const subSchema of resolvedSchema.allOf) {\n        const subProperties = getSchemaProperties(subSchema);\n        Object.assign(mergedProperties, subProperties);\n      }\n      return mergedProperties;\n    }\n\n    return {};\n  };\n\n  /**\n   * 处理参数集合，按位置分组\n   * @param parameters 参数对象数组\n   * @returns 按位置分组的参数\n   */\n  const processParameters = (\n    parameters: (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[] | undefined,\n  ) => {\n    if (!parameters || parameters.length === 0) {\n      return {};\n    }\n\n    const result: { [key: string]: (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[] } = {\n      path: [],\n      query: [],\n      header: [],\n      cookie: [],\n    };\n\n    for (const param of parameters) {\n      const resolvedParam = resolve<OpenAPIV3.ParameterObject>(param, \"parameters\");\n      if (resolvedParam && resolvedParam.in) {\n        const paramIn = resolvedParam.in as keyof typeof result;\n        if (paramIn in result && result[paramIn]) {\n          result[paramIn].push(resolvedParam);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * 处理响应对象\n   * @param response 响应对象\n   * @returns 处理后的响应对象\n   */\n  const processResponse = (\n    response: OpenAPIV3.ResponseObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!response) return null;\n\n    const resolvedResponse = resolve<OpenAPIV3.ResponseObject>(response, \"responses\");\n    if (!resolvedResponse) return null;\n\n    const result = {\n      description: resolvedResponse.description || \"\",\n      headers: resolvedResponse.headers || {},\n      content: resolvedResponse.content || {},\n    };\n\n    return result;\n  };\n\n  /**\n   * 获取模式的约束条件\n   * @param schema 模式对象\n   * @returns 约束条件对象\n   */\n  const getSchemaConstraints = (\n    schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined,\n  ) => {\n    if (!schema) return {};\n\n    const resolvedSchema = resolve<OpenAPIV3.SchemaObject>(schema, \"schemas\");\n    if (!resolvedSchema) return {};\n\n    const constraints: { [key: string]: any } = {};\n\n    // 数值约束\n    if (typeof resolvedSchema.minimum === \"number\") {\n      constraints.minimum = resolvedSchema.minimum;\n    }\n    if (typeof resolvedSchema.maximum === \"number\") {\n      constraints.maximum = resolvedSchema.maximum;\n    }\n    if (typeof resolvedSchema.exclusiveMinimum === \"number\") {\n      constraints.exclusiveMinimum = resolvedSchema.exclusiveMinimum;\n    }\n    if (typeof resolvedSchema.exclusiveMaximum === \"number\") {\n      constraints.exclusiveMaximum = resolvedSchema.exclusiveMaximum;\n    }\n    if (typeof resolvedSchema.multipleOf === \"number\") {\n      constraints.multipleOf = resolvedSchema.multipleOf;\n    }\n\n    // 字符串约束\n    if (typeof resolvedSchema.minLength === \"number\") {\n      constraints.minLength = resolvedSchema.minLength;\n    }\n    if (typeof resolvedSchema.maxLength === \"number\") {\n      constraints.maxLength = resolvedSchema.maxLength;\n    }\n    if (resolvedSchema.pattern) {\n      constraints.pattern = resolvedSchema.pattern;\n    }\n\n    // 数组约束\n    if (typeof resolvedSchema.minItems === \"number\") {\n      constraints.minItems = resolvedSchema.minItems;\n    }\n    if (typeof resolvedSchema.maxItems === \"number\") {\n      constraints.maxItems = resolvedSchema.maxItems;\n    }\n    if (resolvedSchema.uniqueItems) {\n      constraints.uniqueItems = resolvedSchema.uniqueItems;\n    }\n\n    // 对象约束\n    if (typeof resolvedSchema.minProperties === \"number\") {\n      constraints.minProperties = resolvedSchema.minProperties;\n    }\n    if (typeof resolvedSchema.maxProperties === \"number\") {\n      constraints.maxProperties = resolvedSchema.maxProperties;\n    }\n\n    return constraints;\n  };\n\n  /**\n   * 获取指定路径和方法的操作对象\n   * @param path 路径\n   * @param method HTTP方法\n   * @returns 操作对象\n   */\n  const getOperation = (\n    path: string,\n    method: string,\n  ): OpenAPIV3.OperationObject | null => {\n    if (!spec || !spec.paths || !spec.paths[path]) {\n      return null;\n    }\n\n    const pathItem = spec.paths[path] as OpenAPIV3.PathItemObject;\n    const operation = pathItem[method.toLowerCase() as keyof OpenAPIV3.PathItemObject];\n\n    if (operation && typeof operation === \"object\" && \"responses\" in operation) {\n      return operation as OpenAPIV3.OperationObject;\n    }\n\n    return null;\n  };\n\n  /**\n   * 获取服务器列表\n   * @returns 服务器对象数组\n   */\n  const getServers = (): OpenAPIV3.ServerObject[] => {\n    return spec?.servers || [];\n  };\n\n  /**\n   * 按标签分组获取操作\n   * @returns 按标签分组的操作对象\n   */\n  const getOperationsByTag = () => {\n    if (!spec || !spec.paths) {\n      return {};\n    }\n\n    const operations: { [tag: string]: Array<{ path: string; method: string; operation: OpenAPIV3.OperationObject }> } = {};\n\n    Object.entries(spec.paths).forEach(([path, pathItem]) => {\n      if (!pathItem || typeof pathItem !== \"object\") return;\n\n      const methods = [\"get\", \"post\", \"put\", \"delete\", \"patch\", \"head\", \"options\", \"trace\"];\n\n      methods.forEach((method) => {\n        const operation = pathItem[method as keyof OpenAPIV3.PathItemObject];\n        if (operation && typeof operation === \"object\" && \"responses\" in operation) {\n          const op = operation as OpenAPIV3.OperationObject;\n          const tags = op.tags || [\"default\"];\n\n          tags.forEach((tag) => {\n            if (!operations[tag]) {\n              operations[tag] = [];\n            }\n            operations[tag].push({\n              path,\n              method: method.toUpperCase(),\n              operation: op,\n            });\n          });\n        }\n      });\n    });\n\n    return operations;\n  };\n\n  /**\n   * 获取所有标签\n   * @returns 标签数组\n   */\n  const getTags = () => {\n    if (!spec) return [];\n    return spec.tags || [];\n  };\n\n  /**\n   * 获取API信息\n   * @returns API信息对象\n   */\n  const getInfo = () => {\n    return spec?.info || null;\n  };\n\n  /**\n   * 获取组件定义\n   * @returns 组件对象\n   */\n  const getComponents = () => {\n    return spec?.components || null;\n  };\n\n  return {\n    // 原始数据\n    spec,\n    components,\n\n    // 解析函数\n    resolve,\n\n    // 模式处理\n    getSchemaType,\n    getSchemaProperties,\n    getSchemaConstraints,\n    getRequestBodySchema,\n\n    // 参数和响应处理\n    processParameters,\n    processResponse,\n\n    // 操作处理\n    getOperation,\n    getOperationsByTag,\n    getTags,\n\n    // 服务器和基本信息\n    getServers,\n    getInfo,\n    getComponents,\n  };\n}\n",
      "type": "registry:lib",
      "target": "lib/hooks/use-openapi.ts"
    },
    {
      "path": "registry/lib/hooks/use-operation.ts",
      "content": "import { useMemo } from 'react';\n\n/**\n * Hook for working with OpenAPI operations\n * @param operation - The operation object\n * @param path - The path string\n * @param method - The HTTP method\n * @returns Operation utilities\n */\nexport function useOperation(\n  operation: any,\n  path: string,\n  method: string\n) {\n  return useMemo(() => {\n    const getOperationId = () => {\n      return operation.operationId || `${method.toLowerCase()}-${path}`;\n    };\n\n    const getTags = () => {\n      return operation.tags || [];\n    };\n\n    const getParameters = () => {\n      return operation.parameters || [];\n    };\n\n    const getRequestBody = () => {\n      return operation.requestBody;\n    };\n\n    const getResponses = () => {\n      return operation.responses || {};\n    };\n\n    const getSecurity = () => {\n      return operation.security || [];\n    };\n\n    return {\n      getOperationId,\n      getTags,\n      getParameters,\n      getRequestBody,\n      getResponses,\n      getSecurity,\n    };\n  }, [operation, path, method]);\n}\n",
      "type": "registry:lib",
      "target": "lib/hooks/use-operation.ts"
    },
    {
      "path": "registry/lib/hooks/use-schema.ts",
      "content": "import { useMemo } from 'react';\nimport { resolveRef } from '../utils/resolve-ref';\n\n/**\n * Hook for working with OpenAPI schemas\n * @param schema - The schema object or reference\n * @param components - The components object containing schemas\n * @returns Resolved schema and utility functions\n */\nexport function useSchema(\n  schema: any,\n  components: any\n) {\n  return useMemo(() => {\n    const resolvedSchema = schema.$ref ? resolveRef(schema, components) : schema;\n\n    const getType = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== 'object') return 'unknown';\n      return resolvedSchema.type || 'object';\n    };\n\n    const isRequired = (propertyName: string) => {\n      if (!resolvedSchema || typeof resolvedSchema !== 'object') return false;\n      return resolvedSchema.required?.includes(propertyName) || false;\n    };\n\n    const getProperties = () => {\n      if (!resolvedSchema || typeof resolvedSchema !== 'object') return {};\n      return resolvedSchema.properties || {};\n    };\n\n    return {\n      resolvedSchema,\n      getType,\n      isRequired,\n      getProperties,\n    };\n  }, [schema, components]);\n}\n",
      "type": "registry:lib",
      "target": "lib/hooks/use-schema.ts"
    },
    {
      "path": "registry/lib/i18n/I18nProvider.tsx",
      "content": "\"use client\";\n\nimport React, { createContext, useContext, useState } from \"react\";\nimport en from \"./locales/en\";\nimport zh from \"./locales/zh\";\n\ntype LocaleStrings = Record<string, string>;\nconst locales: Record<string, LocaleStrings> = { en, zh };\n\ninterface I18nContextProps {\n  locale: \"en\" | \"zh\";\n  setLocale: (locale: \"en\" | \"zh\") => void;\n  t: (key: string) => string;\n}\n\nconst I18nContext = createContext<I18nContextProps | undefined>(undefined);\n\nexport const I18nProvider: React.FC<{ children: React.ReactNode }> = ({\n  children,\n}) => {\n  const [locale, setLocale] = useState<\"en\" | \"zh\">(\"en\");\n\n  const t = (key: string): string => {\n    // 直接使用扁平结构查找，如果未找到则返回原key\n    return locales[locale]?.[key] || key;\n  };\n\n  return (\n    <I18nContext.Provider value={{ locale, setLocale, t }}>\n      {children}\n    </I18nContext.Provider>\n  );\n};\n\n// 创建一个默认的翻译函数，使用英文作为默认语言\nconst createDefaultTranslator = (defaultLocale: \"en\" | \"zh\" = \"en\") => {\n  return (key: string): string => {\n    return locales[defaultLocale]?.[key] || key;\n  };\n};\n\n// 重构后的 useI18n hook，支持在没有 provider 的情况下使用默认语言\nexport const useI18n = (): I18nContextProps => {\n  const context = useContext(I18nContext);\n\n  // 如果没有 provider，返回默认的 i18n 对象\n  if (!context) {\n    const defaultT = createDefaultTranslator(\"en\");\n    return {\n      locale: \"en\",\n      setLocale: () => {\n        console.warn(\"useI18n: setLocale called outside of I18nProvider. Language switching is not available.\");\n      },\n      t: defaultT,\n    };\n  }\n\n  return context;\n};\n\n// 导出一个独立的翻译函数，可以在组件外部使用\nexport const t = createDefaultTranslator(\"en\");\n\n// 导出一个创建翻译函数的工厂函数\nexport const createTranslator = (locale: \"en\" | \"zh\" = \"en\") => {\n  return createDefaultTranslator(locale);\n};\n",
      "type": "registry:lib",
      "target": "lib/i18n/I18nProvider.tsx"
    },
    {
      "path": "registry/lib/utils/generate-example.ts",
      "content": "import { resolveRef } from \"@/registry/lib/utils/resolve-ref\";\nimport { faker } from '@faker-js/faker';\nimport type { OpenAPIV3 } from 'openapi-types';\n\n// 配置 faker.js\n// 注意：@faker-js/faker 8.x 版本不再支持 setLocale，使用默认语言\n\n/**\n * 根据OpenAPI Schema生成示例数据\n *\n * @param schema 要生成示例的Schema对象\n * @param components 引用解析所需的components\n * @param options 额外配置选项\n * @returns 生成的示例数据\n */\nexport function generateExample(\n  schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject,\n  components?: OpenAPIV3.ComponentsObject,\n  options: {\n    maxDepth?: number;\n    currentDepth?: number;\n    includeReadOnly?: boolean;\n    includeWriteOnly?: boolean;\n  } = {},\n): any {\n  // 默认选项\n  const {\n    maxDepth = 3,\n    currentDepth = 0,\n    includeReadOnly = true,\n    includeWriteOnly = true,\n  } = options;\n\n  // 防止过深递归\n  if (currentDepth > maxDepth) {\n    return {};\n  }\n\n  // 解析引用\n  let resolvedSchema: OpenAPIV3.SchemaObject | null = null;\n  if (\"$ref\" in schema) {\n    resolvedSchema = resolveRef<OpenAPIV3.SchemaObject>(schema, components, \"schemas\");\n    if (!resolvedSchema) {\n      console.warn(`无法解析引用: ${schema.$ref}`);\n      return {};\n    }\n  } else {\n    resolvedSchema = schema;\n  }\n\n  // 如果提供了example，直接使用\n  if (resolvedSchema.example !== undefined) {\n    return resolvedSchema.example;\n  }\n\n  // 如果提供了default，使用默认值\n  if (resolvedSchema.default !== undefined) {\n    return resolvedSchema.default;\n  }\n\n  // 如果有enum，返回第一个枚举值\n  if (resolvedSchema.enum && resolvedSchema.enum.length > 0) {\n    return resolvedSchema.enum[0];\n  }\n\n  // 根据type生成示例\n  const type = resolvedSchema.type;\n\n  // 处理复合模式\n  if (resolvedSchema.allOf && resolvedSchema.allOf.length > 0) {\n    // 合并所有allOf模式\n    const mergedExample = {};\n    for (const subSchema of resolvedSchema.allOf) {\n      const subExample = generateExample(subSchema, components, {\n        ...options,\n        currentDepth: currentDepth + 1,\n      });\n      Object.assign(mergedExample, subExample);\n    }\n    return mergedExample;\n  }\n\n  if (resolvedSchema.oneOf && resolvedSchema.oneOf.length > 0) {\n    // 使用第一个oneOf模式\n    const firstSchema = resolvedSchema.oneOf[0];\n    if (firstSchema) {\n      return generateExample(firstSchema, components, {\n        ...options,\n        currentDepth: currentDepth + 1,\n      });\n    }\n  }\n\n  if (resolvedSchema.anyOf && resolvedSchema.anyOf.length > 0) {\n    // 使用第一个anyOf模式\n    const firstSchema = resolvedSchema.anyOf[0];\n    if (firstSchema) {\n      return generateExample(firstSchema, components, {\n        ...options,\n        currentDepth: currentDepth + 1,\n      });\n    }\n  }\n\n  // 根据类型处理\n  switch (type) {\n    case \"string\": {\n      // 为不同格式生成合适的字符串\n      const format = resolvedSchema.format;\n      const propName = resolvedSchema.title || '';\n\n      if (format === \"date\") {\n        return faker.date.recent({ days: 30 }).toISOString().split(\"T\")[0]; // YYYY-MM-DD\n      } else if (format === \"date-time\") {\n        return faker.date.recent({ days: 30 }).toISOString(); // YYYY-MM-DDThh:mm:ss.sssZ\n      } else if (format === \"email\") {\n        return faker.internet.email();\n      } else if (format === \"uuid\") {\n        return faker.string.uuid();\n      } else if (format === \"uri\" || format === \"url\") {\n        return faker.internet.url();\n      } else if (format === \"hostname\") {\n        return faker.internet.domainName();\n      } else if (format === \"ipv4\") {\n        return faker.internet.ipv4();\n      } else if (format === \"ipv6\") {\n        return faker.internet.ipv6();\n      } else if (format === \"password\") {\n        return faker.internet.password({ length: 12 });\n      } else if (format === \"byte\") {\n        return faker.string.alphanumeric(8);\n      } else if (format === \"binary\") {\n        return faker.string.binary({ length: 16 });\n      } else if (resolvedSchema.pattern) {\n        // 对于有模式的，尝试生成符合模式的示例\n        return `${faker.lorem.word()}_${faker.string.alphanumeric(6)}`;\n      } else {\n        // 根据属性名推断类型生成合适的示例\n        const lowerPropName = propName.toLowerCase();\n\n        // 基础信息类\n        if (lowerPropName.includes('name') || lowerPropName.includes('title')) {\n          return faker.person.fullName();\n        } else if (lowerPropName.includes('email')) {\n          return faker.internet.email();\n        } else if (lowerPropName.includes('phone') || lowerPropName.includes('mobile') || lowerPropName.includes('tel')) {\n          return faker.phone.number();\n        } else if (lowerPropName.includes('username') || lowerPropName.includes('user_name')) {\n          return faker.internet.userName();\n        } else if (lowerPropName.includes('password') || lowerPropName.includes('passwd')) {\n          return faker.internet.password({ length: 12 });\n        }\n\n        // 姓名相关\n        else if (lowerPropName.includes('first') && (lowerPropName.includes('name') || lowerPropName.includes('_name'))) {\n          return faker.person.firstName();\n        } else if (lowerPropName.includes('last') && (lowerPropName.includes('name') || lowerPropName.includes('_name'))) {\n          return faker.person.lastName();\n        } else if (lowerPropName.includes('full') && lowerPropName.includes('name')) {\n          return faker.person.fullName();\n        } else if (lowerPropName.includes('middle') && lowerPropName.includes('name')) {\n          return faker.person.middleName();\n        }\n\n        // 地址相关\n        else if (lowerPropName.includes('address')) {\n          return faker.location.streetAddress({ useFullAddress: true });\n        } else if (lowerPropName.includes('street')) {\n          return faker.location.street();\n        } else if (lowerPropName.includes('city')) {\n          return faker.location.city();\n        } else if (lowerPropName.includes('state') || lowerPropName.includes('province')) {\n          return faker.location.state();\n        } else if (lowerPropName.includes('country')) {\n          return faker.location.country();\n        } else if (lowerPropName.includes('zip') || lowerPropName.includes('postal')) {\n          return faker.location.zipCode();\n        }\n\n        // 公司相关\n        else if (lowerPropName.includes('company') || lowerPropName.includes('organization')) {\n          return faker.company.name();\n        } else if (lowerPropName.includes('department')) {\n          return faker.commerce.department();\n        } else if (lowerPropName.includes('position') || lowerPropName.includes('job') || lowerPropName.includes('role')) {\n          return faker.person.jobTitle();\n        }\n\n        // 网络相关\n        else if (lowerPropName.includes('url') || lowerPropName.includes('website') || lowerPropName.includes('link')) {\n          return faker.internet.url();\n        } else if (lowerPropName.includes('domain')) {\n          return faker.internet.domainName();\n        } else if (lowerPropName.includes('ip')) {\n          return faker.internet.ipv4();\n        }\n\n        // 媒体相关\n        else if (lowerPropName.includes('avatar') || lowerPropName.includes('image') || lowerPropName.includes('photo')) {\n          return faker.image.avatar();\n        } else if (lowerPropName.includes('color') || lowerPropName.includes('colour')) {\n          return faker.color.human();\n        }\n\n        // 商业相关\n        else if (lowerPropName.includes('product')) {\n          return faker.commerce.productName();\n        } else if (lowerPropName.includes('price') || lowerPropName.includes('amount') || lowerPropName.includes('cost')) {\n          return faker.commerce.price();\n        } else if (lowerPropName.includes('currency')) {\n          return faker.finance.currencyCode();\n        } else if (lowerPropName.includes('sku') || lowerPropName.includes('code')) {\n          return faker.string.alphanumeric(8).toUpperCase();\n        }\n\n        // 内容相关\n        else if (lowerPropName.includes('description') || lowerPropName.includes('desc')) {\n          return faker.lorem.sentence();\n        } else if (lowerPropName.includes('comment') || lowerPropName.includes('note') || lowerPropName.includes('remark')) {\n          return faker.lorem.sentence();\n        } else if (lowerPropName.includes('content') || lowerPropName.includes('text') || lowerPropName.includes('body')) {\n          return faker.lorem.paragraph();\n        } else if (lowerPropName.includes('summary') || lowerPropName.includes('excerpt')) {\n          return faker.lorem.sentence();\n        }\n\n        // 状态和分类\n        else if (lowerPropName.includes('status')) {\n          return faker.helpers.arrayElement(['active', 'inactive', 'pending', 'completed', 'draft', 'published']);\n        } else if (lowerPropName.includes('type')) {\n          return faker.helpers.arrayElement(['standard', 'premium', 'basic', 'advanced']);\n        } else if (lowerPropName.includes('tag') || lowerPropName.includes('category')) {\n          return faker.helpers.arrayElement(['technology', 'business', 'design', 'marketing', 'finance', 'education']);\n        } else if (lowerPropName.includes('priority')) {\n          return faker.helpers.arrayElement(['low', 'medium', 'high', 'urgent']);\n        }\n\n        // 个人信息\n        else if (lowerPropName.includes('age')) {\n          return faker.number.int({ min: 18, max: 80 }).toString();\n        } else if (lowerPropName.includes('gender') || lowerPropName.includes('sex')) {\n          return faker.person.gender();\n        } else if (lowerPropName.includes('birthday') || lowerPropName.includes('birth')) {\n          return faker.date.birthdate().toISOString().split('T')[0];\n        }\n\n        // ID 相关\n        else if (lowerPropName.includes('id') && lowerPropName.length <= 5) {\n          return faker.string.numeric(8);\n        } else if (lowerPropName.includes('uuid') || lowerPropName.includes('guid')) {\n          return faker.string.uuid();\n        }\n\n        // 其他常见字段\n        else if (lowerPropName.includes('version')) {\n          return faker.system.semver();\n        } else if (lowerPropName.includes('count') || lowerPropName.includes('number') || lowerPropName.includes('num')) {\n          return faker.number.int({ min: 1, max: 100 }).toString();\n        } else if (lowerPropName.includes('size')) {\n          return faker.helpers.arrayElement(['small', 'medium', 'large']);\n        } else if (lowerPropName.includes('format')) {\n          return faker.helpers.arrayElement(['json', 'xml', 'csv', 'pdf']);\n        }\n\n        else {\n          // 默认生成随机词语\n          return faker.lorem.words(2);\n        }\n      }\n    }\n\n    case \"number\":\n    case \"integer\": {\n      // 处理数字范围\n      if (\n        resolvedSchema.minimum !== undefined &&\n        resolvedSchema.maximum !== undefined\n      ) {\n        const min = resolvedSchema.minimum;\n        const max = resolvedSchema.maximum;\n        return type === \"integer\"\n          ? faker.number.int({ min, max })\n          : faker.number.float({ min, max, fractionDigits: 2 });\n      } else if (resolvedSchema.minimum !== undefined) {\n        const min = resolvedSchema.minimum;\n        const max = min + 1000;\n        return type === \"integer\"\n          ? faker.number.int({ min, max })\n          : faker.number.float({ min, max, fractionDigits: 2 });\n      } else if (resolvedSchema.maximum !== undefined) {\n        const max = resolvedSchema.maximum;\n        const min = Math.max(0, max - 1000);\n        return type === \"integer\"\n          ? faker.number.int({ min, max })\n          : faker.number.float({ min, max, fractionDigits: 2 });\n      } else {\n        return type === \"integer\"\n          ? faker.number.int({ min: 1, max: 100 })\n          : faker.number.float({ min: 1, max: 100, fractionDigits: 2 });\n      }\n    }\n\n    case \"boolean\":\n      return faker.datatype.boolean();\n\n    case \"array\": {\n      // 检查items定义\n      if (!resolvedSchema.items) {\n        return [];\n      }\n\n      // 生成 1-3 个元素的数组作为示例\n      const length = faker.number.int({ min: 1, max: 3 });\n      const result = [];\n\n      for (let i = 0; i < length; i++) {\n        const itemExample = generateExample(resolvedSchema.items, components, {\n          ...options,\n          currentDepth: currentDepth + 1,\n        });\n        result.push(itemExample);\n      }\n\n      return result;\n    }\n\n    case \"object\":\n    default: {\n      // 对于对象或未指定类型但有properties的情况\n      const result: Record<string, any> = {};\n\n      if (resolvedSchema.properties) {\n        // 遍历所有属性\n        for (const [propName, propSchema] of Object.entries(\n          resolvedSchema.properties,\n        )) {\n          // 跳过只读/只写属性（如果配置了）\n          if (\n            ((propSchema as OpenAPIV3.SchemaObject).readOnly && !includeReadOnly) ||\n            ((propSchema as OpenAPIV3.SchemaObject).writeOnly && !includeWriteOnly)\n          ) {\n            continue;\n          }\n\n          // 创建增强的 schema，包含属性名信息用于智能推断\n          const enhancedSchema = {\n            ...(propSchema as OpenAPIV3.SchemaObject),\n            title: (propSchema as OpenAPIV3.SchemaObject).title || propName,\n          };\n\n          // 递归生成属性值\n          result[propName] = generateExample(enhancedSchema, components, {\n            ...options,\n            currentDepth: currentDepth + 1,\n          });\n        }\n      }\n\n      return result;\n    }\n  }\n}\n",
      "type": "registry:lib",
      "target": "lib/utils/generate-example.ts"
    },
    {
      "path": "registry/lib/utils/resolve-ref.ts",
      "content": "import type { OpenAPIV3 } from 'openapi-types';\n\n/**\n * 解析OpenAPI中的引用对象\n * @param obj 可能是引用对象的数据\n * @param components OpenAPI组件定义\n * @param category 可选的组件类别(schemas, parameters等)\n * @returns 解析后的对象或原始对象\n */\nexport function resolveRef<T>(\n  obj: T | OpenAPIV3.ReferenceObject | undefined,\n  components?: OpenAPIV3.ComponentsObject,\n  category?: string,\n): T | null {\n  if (!obj) return null;\n\n  // 检查是否是引用对象\n  if (typeof obj === \"object\" && obj !== null && \"$ref\" in obj) {\n    const refObj = obj as OpenAPIV3.ReferenceObject;\n    const refPath = refObj.$ref;\n\n    // 处理标准格式的引用 #/components/{category}/{name}\n    const refMatch = refPath.match(/^#\\/components\\/([^/]+)\\/(.+)$/);\n\n    if (refMatch && components) {\n      const [, refCategory, refName] = refMatch;\n\n      // 检查refName是否存在\n      if (!refName) {\n        console.warn(`引用名称为空: ${refPath}`);\n        return null;\n      }\n\n      // 如果指定了类别，并且与引用类别不一致，则发出警告\n      if (category && refCategory !== category) {\n        console.warn(`引用类别 ${refCategory} 与期望类别 ${category} 不一致`);\n      }\n\n      // 根据类别获取组件集合\n      const componentCollection =\n        components[refCategory as keyof OpenAPIV3.ComponentsObject];\n\n      if (componentCollection && typeof componentCollection === \"object\") {\n        // 解析引用对象\n        const resolved = componentCollection[refName];\n\n        if (resolved) {\n          // 检查是否是嵌套引用，如果是则递归解析\n          if (\n            typeof resolved === \"object\" &&\n            resolved !== null &&\n            \"$ref\" in resolved\n          ) {\n            return resolveRef<T>(\n              resolved as OpenAPIV3.ReferenceObject,\n              components,\n              category,\n            );\n          }\n          return resolved as unknown as T;\n        }\n      }\n\n      console.warn(`找不到引用 ${refPath}`);\n      return null;\n    }\n\n    console.warn(`不支持的引用格式 ${refPath}`);\n    return null;\n  }\n\n  // 如果不是引用对象，则返回原始对象\n  return obj as T;\n}\n",
      "type": "registry:lib",
      "target": "lib/utils/resolve-ref.ts"
    },
    {
      "path": "registry/lib/utils/schema-utils.ts",
      "content": "/**\n * Check if a schema is a reference object\n */\nexport function isReferenceObject(obj: any): obj is { $ref: string } {\n  return obj && typeof obj === 'object' && '$ref' in obj;\n}\n\n/**\n * Check if a schema is a schema object\n */\nexport function isSchemaObjectNotRef(obj: any): boolean {\n  return obj && typeof obj === 'object' && !('$ref' in obj);\n}\n\n/**\n * Get the type of a schema\n */\nexport function getSchemaType(schema: any): string {\n  if (schema.type) {\n    return schema.type;\n  }\n  if (schema.allOf) {\n    return 'allOf';\n  }\n  if (schema.oneOf) {\n    return 'oneOf';\n  }\n  if (schema.anyOf) {\n    return 'anyOf';\n  }\n  return 'object';\n}\n\n/**\n * Check if a property is required in a schema\n */\nexport function isPropertyRequired(schema: any, propertyName: string): boolean {\n  return schema.required?.includes(propertyName) || false;\n}\n",
      "type": "registry:lib",
      "target": "lib/utils/schema-utils.ts"
    },
    {
      "path": "registry/lib/utils/type-utils.ts",
      "content": "/**\n * Type guards and utility functions for OpenAPI types\n */\n\nexport function isParameterObject(obj: any): boolean {\n  return obj && typeof obj === 'object' && 'name' in obj && 'in' in obj;\n}\n\nexport function isRequestBodyObject(obj: any): boolean {\n  return obj && typeof obj === 'object' && 'content' in obj;\n}\n\nexport function isResponseObject(obj: any): boolean {\n  return obj && typeof obj === 'object' && 'description' in obj;\n}\n\nexport function isHeaderObject(obj: any): boolean {\n  return obj && typeof obj === 'object' && !('name' in obj) && !('in' in obj);\n}\n\nexport function isSchemaObject(obj: any): boolean {\n  return obj && typeof obj === 'object' && 'type' in obj;\n}\n\nexport function isComponentObject(obj: any): boolean {\n  return obj && typeof obj === 'object' && !('$ref' in obj) && !('type' in obj);\n}\n\nexport function isLinkObject(obj: any): boolean {\n  return obj && typeof obj === 'object' && ('operationRef' in obj || 'operationId' in obj);\n}\n\nexport function isExampleObject(obj: any): boolean {\n  return obj && typeof obj === 'object' && ('value' in obj || 'externalValue' in obj);\n}\n",
      "type": "registry:lib",
      "target": "lib/utils/type-utils.ts"
    }
  ]
}